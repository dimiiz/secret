-- analyzer
 
BossCreaturePanel < Panel
  height: 38
 
  UICreature
    id: creature
    size: 35 35
    anchors.left: parent.left
    anchors.verticalCenter: parent.verticalCenter
    old-scaling: true
    margin-left: 3
 
  Label
    id: name
    anchors.left: creature.right
    margin: 1
    margin-left: 5
    margin-top: 4
    anchors.top: parent.top
    anchors.bottom: creature.verticalCenter
    anchors.right: parent.right
    font: verdana-11px-rounded
    color: #FFFFFF
    text: Duke Krule
 
  Label
    id: cooldown
    anchors.left: creature.right
    margin: 1
    margin-left: 5
    anchors.right: parent.right
    anchors.bottom: parent.bottom
    anchors.top: creature.verticalCenter
    font: verdana-11px-rounded
    text: 19h 20min
 
 
SearchPanel < TextEdit
  placeholder: Type to search
  margin-top: 1
  @onClick: modules.client_textedit.show(self)
 
  Button
    id: clear
    anchors.right: parent.right
    margin-right: -2
    anchors.verticalCenter: parent.verticalCenter
    size: 18 18
    text: X
    @onClick: |
      self:getParent():setText("")
 
TrackerItem < Panel
  height: 40
 
  BotItem
    id: item
    anchors.top: parent.top
    margin-top: 2
    anchors.left: parent.left
    image-source:
 
  UIWidget
    id: name
    anchors.top: prev.top
    margin-top: 1
    anchors.bottom: prev.verticalCenter
    anchors.left: prev.right
    anchors.right: parent.right
    margin-left: 5
    text: Set Item to start track.
    text-align:left
    font: verdana-11px-rounded
    color: #FFFFFF
 
  UIWidget
    id: drops
    anchors.top: prev.bottom
    margin-top: 3
    anchors.bottom: Item.bottom
    anchors.left: prev.left
    anchors.right: parent.right    
    font: verdana-11px-rounded
    text-align:left
    text: Loot Drops: 0
    color: #CCCCCC
 
 
DualLabel < Label
  height: 15
  text-offset: 4 0
  font: verdana-11px-rounded
  text-align: left
  width: 50
 
  Label
    id: value
    anchors.right: parent.right
    margin-right: 4
    anchors.verticalCenter: parent.verticalCenter
    width: 200
    font: verdana-11px-rounded
    text-align: right
    text: 0
 
MemberWidget < Panel
  height: 85
  margin-top: 3
 
  UICreature
    id: creature
    anchors.top: parent.top
    anchors.left: parent.left
    anchors.bottom: parent.bottom
    size: 28 28
 
  UIWidget
    id: name
    anchors.left: prev.right
    margin-left: 5
    anchors.top: parent.top
    height: 12
    anchors.right: parent.right
    text: Player Name
    font: verdana-11px-rounded
    text-align: left     
 
  ProgressBar
    id: health
    anchors.left: prev.left
    anchors.right: parent.right
    anchors.top: prev.bottom
    margin-top: 2
    height: 7
    background-color: #00c000
    phantom: false 
 
  ProgressBar
    id: mana
    anchors.left: prev.left
    anchors.right: parent.right
    anchors.top: prev.bottom
    height: 7
    background-color: #0000FF
    phantom: false
 
  DualLabel
    id: balance
    anchors.top: prev.bottom
    anchors.left: parent.left
    anchors.right: parent.right
    margin-top: 5
    text: Balance:
 
  DualLabel
    id: damage
    anchors.top: prev.bottom
    anchors.left: parent.left
    anchors.right: parent.right
    margin-top: 2
    text: Damage:    
 
  DualLabel
    id: healing
    anchors.top: prev.bottom
    anchors.left: parent.left
    anchors.right: parent.right
    margin-top: 2
    text: Healing:    
 
AnalyzerPriceLabel < Label
  background-color: alpha
  text-offset: 2 0
  focusable: true
  height: 16
 
  $focus:
    background-color: #00000055
 
  Button
    id: remove
    !text: tr('x')
    anchors.right: parent.right
    margin-right: 15
    width: 15
    height: 15
 
AnalyzerListPanel < Panel
  padding-left: 4
  padding-right: 4
  layout:
    type: verticalBox
    fit-children: true
 
 
ListLabel < Label
  height: 15
  font: verdana-11px-rounded
  text-offset: 15 0
 
AnalyzerItemsPanel < Panel
  id: List
  padding: 2
  layout:
    type: grid
    cell-size: 33 33
    cell-spacing: 1
    num-columns: 5
    fit-children: true
 
AnalyzerLootItem < UIItem
  opacity: 0.87
  height: 37
  margin-left: 1
  virtual: true
  background-color: alpha 
 
  Label
    id: count
    font: verdana-11px-rounded
    color: white
    opacity: 0.87
    anchors.left: parent.left
    anchors.right: parent.right
    anchors.bottom: parent.bottom
    margin-right: 2
    text-align: right
    text: 0
 
AnalyzerGraph < UIGraph
  height: 140
  capacity: 400
  line-width: 1
  color: red
  margin-top: 5
  margin-left: 5
  margin-right: 5
  background-color: #383636
  padding: 5
  font: verdana-11px-rounded
  image-source: /images/ui/graph_background
 
AnalyzerProgressBar < ProgressBar
  background-color: green
  height: 5
  margin-top: 3
  phantom: false
  margin-left: 3
  margin-right: 3
  border: 1 black
 
AnalyzerButton < Button
  height: 22
  margin-bottom: 2
  font: verdana-11px-rounded
  text-offset: 0 4
 
MainAnalyzerWindow < MiniWindow
  id: MainAnalyzerWindow
  text: Analytics Selector
  height: 293
  icon: /images/topbuttons/analyzers
 
  MiniWindowContents
    padding-left: 5
    padding-right: 5
    padding-top: 5
    layout: verticalBox
 
    AnalyzerButton
      id: HuntingAnalyzer
      text: Hunting Analyzer
 
    AnalyzerButton
      id: LootAnalyzer
      text: Loot Analyzer
 
    AnalyzerButton
      id: SupplyAnalyzer
      text: Supply Analyzer    
  
    AnalyzerButton
      id: ImpactAnalyzer
      text: Impact Analyzer
 
    AnalyzerButton
      id: XPAnalyzer
      text: XP Analyzer
 
    AnalyzerButton
      id: DropTracker
      text: Drop Tracker
 
    AnalyzerButton
      id: Stats
      text: CaveBot Stats
      color: #74B73E
 
    AnalyzerButton
      id: PartyHunt
      text: Party Hunt
      color: #3895D3
 
    AnalyzerButton
      id: BossTracker
      text: Boss Cooldowns
      color: #df3afb
 
    AnalyzerButton
      id: Settings
      text: Features & Settings
      color: #FABD02
 
    AnalyzerButton
      id: ResetSession
      text: Reset Session
      color: #FF0000
 
HuntingAnalyzer < MiniWindow  
  id: HuntingAnalyzerWindow
  text: Hunt Analyzer
  icon: /images/topbuttons/analyzers
 
  MiniWindowContents
    padding-top: 3
    layout: verticalBox
 
LootAnalyzer < MiniWindow
  id: LootAnalyzerWindow    
  text: Loot Analyzer
  icon: /images/topbuttons/analyzers
 
  MiniWindowContents
    padding-top: 3
    layout: verticalBox
 
SupplyAnalyzer < MiniWindow
  id: SupplyAnalyzerWindow    
  text: Supply Analyzer
  icon: /images/topbuttons/analyzers
 
  MiniWindowContents
    padding-top: 3
    layout: verticalBox
 
ImpactAnalyzer < MiniWindow
  id: ImpactAnalyzerWindow    
  text: Impact Analyzer
  icon: /images/topbuttons/analyzers
 
  MiniWindowContents
    padding-top: 3
    layout: verticalBox
 
XPAnalyzer < MiniWindow
  id: XPAnalyzerWindow    
  text: XP Analyzer
  height: 150
  icon: /images/topbuttons/analyzers
 
  MiniWindowContents
    padding-top: 3
    layout: verticalBox
 
PartyAnalyzerWindow < MiniWindow
  id: PartyAnalyzerWindow
  text: Party Hunt
  height: 200
  icon: /images/topbuttons/analyzers
 
  MiniWindowContents
    padding-left: 3
    padding-right: 3
    padding-top: 1
    layout: verticalBox
 
DropTracker < MiniWindow
  id: DropTracker
  text: Drop Tracker
  height: 200
  icon: /images/topbuttons/analyzers
 
  MiniWindowContents
    padding-left: 3
    padding-right: 3
    padding-top: 1
    layout: verticalBox
 
CaveBotStats < MiniWindow
  id: CaveBotStats
  text: CaveBot Stats
  height: 200
  icon: /images/topbuttons/analyzers
 
  MiniWindowContents
    padding-left: 3
    padding-right: 3
    padding-top: 1
    layout: verticalBox
 
BossTracker < MiniWindow
  id: BossTracker
  text: Boss Cooldowns
  height: 200
  icon: /images/topbuttons/analyzers
 
  MiniWindowContents
    padding-left: 3
    padding-right: 3
    padding-top: 1
    layout: verticalBox
 
    SearchPanel
      id: search
 
FeaturesWindow < MainWindow
  id: FeaturesWindow
  size: 250 370
  padding: 15
  text: Analyzers Features
  @onEscape: self:hide()
 
  TextList
    id: CustomPrices
    anchors.top: parent.top
    anchors.left: parent.left
    anchors.right: parent.right
    margin-top: 10
    padding: 1
    height: 220
    vertical-scrollbar: CustomPricesScrollBar
 
  VerticalScrollBar
    id: CustomPricesScrollBar
    anchors.top: CustomPrices.top
    anchors.bottom: CustomPrices.bottom
    anchors.right: CustomPrices.right
    step: 14
    pixels-scroll: true
 
  BotItem
    id: ID
    anchors.left: CustomPrices.left
    anchors.top: CustomPrices.bottom
    margin-top: 5
 
  SpinBox
    id: NewPrice
    anchors.left: prev.right
    margin-left: 5
    anchors.verticalCenter: prev.verticalCenter
    width: 100
    minimum: 0
    maximum: 1000000000
    step: 1
    text-align: center
    focusable: true
 
  Button
    id: addItem
    anchors.left: prev.right
    margin-left: 5
    anchors.verticalCenter: prev.verticalCenter
    anchors.right: CustomPrices.right
    text: Add
    font: verdana-11px-rounded    
 
  HorizontalSeparator
    anchors.left: ID.right
    margin-left: 5
    anchors.right: CustomPrices.right
    anchors.verticalCenter: ID.top
 
  HorizontalSeparator
    id: secondSeparator
    anchors.left: ID.right
    margin-left: 5
    anchors.right: CustomPrices.right
    anchors.bottom: ID.bottom
 
  BotSwitch
    id: LootChannel
    anchors.left: CustomPrices.left
    anchors.right: parent.horizontalCenter
    margin-right: 2
    anchors.top: prev.top
    margin-top: 20
    text: Loot Channel
    font: verdana-11px-rounded   
 
  BotSwitch
    id: RarityFrames
    anchors.left: parent.horizontalCenter
    margin-left: 2
    anchors.right: CustomPrices.right
    anchors.top: secondSeparator.top
    margin-top: 20
    text: Rarity Frames
    font: verdana-11px-rounded   
 
  HorizontalSeparator
    anchors.right: parent.right
    anchors.left: parent.left
    anchors.bottom: closeButton.top
    margin-bottom: 8    
 
  Button
    id: closeButton
    !text: tr('Close')
    font: cipsoftFont
    anchors.right: parent.right
    anchors.bottom: parent.bottom
    size: 45 21
    margin-top: 15
    margin-right: 5 
 
--
 
--[[
  Bot-based Tibia 12 features v1.1
  made by Vithrax
 
  Credits also to:
  - Martín#2318
  - Lee#7725
 
  Thanks for ideas, graphics, functions, design tips!
  
  br, Vithrax
]]
 
-- here you can fix incorrect bosses names in cooldown messages
local BOSSES = {
  -- {in message, correct one}
  {"Scarlet Etzel", "Scarlett Etzel"},
  {"Leiden", "Ravenous Hunger"},
  {"Urmahlulu", "Urmahlullu"}
}
 
vBot.CaveBotData = vBot.CaveBotData or {
  refills = 0,
  rounds = 0,
  time = {},
  lastRefill = os.time(),
  refillTime = {}
}
local lootWorth = 0
local wasteWorth = 0
local balance = 0
local balanceDesc = ""
local hourDesc = ""
local desc = ""
local hour = ""
local launchTime = now
local startExp = exp()
local dmgTable = {}
local healTable = {}
local expTable = {}
local totalDmg = 0
local totalHeal = 0
local dmgDistribution = {}
local first = {l="-", r="0"}
local second = {l="-", r="0"}
local third = {l="-", r="0"}
local fourth = {l="-", r="0"}
local five = {l="-", r="0"}
storage.bestHit = storage.bestHit or 0
storage.bestHeal = storage.bestHeal or 0
local lootedItems = {}
local useData = {}
local usedItems ={}
local lastDataSend = {0, 0}
local analyzerButton
local killList = {}
local membersData = {}
HuntingSessionStart = os.date('%Y-%m-%d, %H:%M:%S')
 
if not storage.analyzers then
  storage.analyzers = {
    trackedLoot = {},
    trackedBoss = {},
    outfits = {},
    customPrices = {},
    lootChannel = true,
    rarityFrames = true,
  }
end
 
storage.analyzers = storage.analyzers or {}
storage.analyzers.trackedLoot = storage.analyzers.trackedLoot or {}
storage.analyzers.trackedBoss = storage.analyzers.trackedBoss or {}
storage.analyzers.outfits = storage.analyzers.outfits or {}
local trackedLoot = storage.analyzers.trackedLoot
 
--destroy old windows
local windowsTable = {"MainAnalyzerWindow", 
                      "HuntingAnalyzerWindow", 
                      "LootAnalyzerWindow", 
                      "SupplyAnalyzerWindow", 
                      "ImpactAnalyzerWindow", 
                      "XPAnalyzerWindow", 
                      "PartyAnalyzerWindow", 
                      "DropTracker", 
                      "CaveBotStats",
                      "BossTracker"
                     }
 
                      for i, window in ipairs(windowsTable) do
  local element = g_ui.getRootWidget():recursiveGetChildById(window)
 
  if element then
    element:destroy()
  end
end
 
local mainWindow = UI.createMiniWindow("MainAnalyzerWindow")
mainWindow:hide()
mainWindow:setContentMaximumHeight(267)
local huntingWindow = UI.createMiniWindow("HuntingAnalyzer")
huntingWindow:hide()
local lootWindow = UI.createMiniWindow("LootAnalyzer")
lootWindow:hide()
local supplyWindow = UI.createMiniWindow("SupplyAnalyzer")
supplyWindow:hide()
local impactWindow = UI.createMiniWindow("ImpactAnalyzer")
impactWindow:hide()
impactWindow:setContentMaximumHeight(615)
local xpWindow = UI.createMiniWindow("XPAnalyzer")
xpWindow:hide()
xpWindow:setContentMaximumHeight(230)
local settingsWindow = UI.createWindow("FeaturesWindow")
settingsWindow:hide()
local partyHuntWindow = UI.createMiniWindow("PartyAnalyzerWindow")
partyHuntWindow:hide()
local dropTrackerWindow = UI.createMiniWindow("DropTracker")
dropTrackerWindow:hide()
local statsWindow = UI.createMiniWindow("CaveBotStats")
statsWindow:hide()
local bossWindow = UI.createMiniWindow("BossTracker")
bossWindow:hide()
 
--f
local toggle = function()
    if mainWindow:isVisible() then
        analyzerButton:setOn(false)
        mainWindow:close()
    else
        analyzerButton:setOn(true)
        mainWindow:open()
    end
end
 
local drawGraph = function(graph, value)
    graph:addValue(value)
end
 
local toggleAnalyzer = function(window)
    if window:isVisible() then
        window:hide()
    else
        window:show()
    end
end
 
local function getSumStats()
  local totalWaste = 0
  local totalLoot = 0
 
  for k,v in pairs(membersData) do
    totalWaste = totalWaste + v.waste
    totalLoot = totalLoot + v.loot
  end
 
  local totalBalance = totalLoot - totalWaste
 
  return totalWaste, totalLoot, totalBalance
end
 
local function clipboardData()
  local totalWaste, totalLoot, totalBalance = getSumStats()
  local final = ""
 
 
  local first = "Session data: From " .. HuntingSessionStart .." to ".. os.date('%Y-%m-%d, %H:%M:%S')
  local second = "Session: " .. sessionTime()
  local third = "Loot Type: Market"
  local fourth = "Loot " .. format_thousand(totalLoot, true)
  local fifth = "Supplies " .. format_thousand(totalWaste, true)
  local six = "Balance " .. format_thousand(totalBalance, true)
 
  local t = {first, second, third, fourth, fifth, six}
  for i, string in ipairs(t) do
    final = final.. "\n"..string
  end
 
  --user data now
  for k,v in pairs(membersData) do
    final = final.. "\n".. k
 
    final = final.. "\n\tLoot "..v.loot
    final = final.. "\n\tSupplies "..v.waste
    final = final.. "\n\tBalance "..v.balance
    final = final.. "\n\tDamage "..v.damage
    final = final.. "\n\tHealing "..v.heal
  end
 
  g_window.setClipboardText(final)
end
 
-- create analyzers button
analyzerButton = modules.game_buttons.buttonsWindow.contentsPanel and modules.game_buttons.buttonsWindow.contentsPanel.buttons.botAnalyzersButton
analyzerButton = analyzerButton or modules.client_topmenu.getButton("botAnalyzersButton")
if analyzerButton then
    analyzerButton:destroy()
end
 
--button
analyzerButton = modules.client_topmenu.addRightGameToggleButton('botAnalyzersButton', 'vBot Analyzers', '/images/topbuttons/analyzers', toggle, false, 999999)
analyzerButton:setOn(false)
 
--toggles window
mainWindow.contentsPanel.HuntingAnalyzer.onClick = function()
    toggleAnalyzer(huntingWindow)
end
mainWindow.onClose = function()
  analyzerButton:setOn(false)
end
mainWindow.contentsPanel.LootAnalyzer.onClick = function()
    toggleAnalyzer(lootWindow)
end
mainWindow.contentsPanel.SupplyAnalyzer.onClick = function()
    toggleAnalyzer(supplyWindow)
end
mainWindow.contentsPanel.ImpactAnalyzer.onClick = function()
    toggleAnalyzer(impactWindow)
end
mainWindow.contentsPanel.XPAnalyzer.onClick = function()
    toggleAnalyzer(xpWindow)
end
mainWindow.contentsPanel.PartyHunt.onClick = function()
  toggleAnalyzer(partyHuntWindow)
end
mainWindow.contentsPanel.DropTracker.onClick = function()
  toggleAnalyzer(dropTrackerWindow)
end
mainWindow.contentsPanel.Stats.onClick = function()
  toggleAnalyzer(statsWindow)
end
mainWindow.contentsPanel.BossTracker.onClick = function()
  toggleAnalyzer(bossWindow)
end
 
-- boss tracker
bossWindow.contentsPanel.search.onTextChange = function(widget, newText)
  newText = newText:lower()
  for i, child in ipairs(bossWindow.contentsPanel:getChildren()) do
    local text = child:getId():lower()
    if child:getId() ~= "search" then
      child:setVisible(text:find(newText))
    end
  end
end
 
-- on login
newTimeFormat = function(v) -- v in seconds
  local hours = string.format("%02.f", math.floor(v/3600))
  local mins = string.format("%02.f", math.floor(v/60 - (hours*60)))
 
  local final = hours.. "h "..mins.."min"
  return final
end
 
function createBossPanel(bossName, dueTime)
  local widget = bossWindow.contentsPanel[bossName] or UI.createWidget("BossCreaturePanel", bossWindow.contentsPanel)
  local outfit = storage.analyzers.outfits[bossName]
 
  widget.time = dueTime
  widget:setId(bossName)
  if outfit then
    widget.creature:setOutfit(outfit)
  else
    widget.creature:setTooltip("Outfit preview not available.\nTo get one you need to 'attack' ".. bossName.."\nOr you need to correct the boss name inside analyzers.lua file, const BOSSES")
  end
  widget.name:setText(bossName)
 
  local timeLeft = os.difftime(dueTime, os.time())
  if timeLeft > 0 then
    widget.cooldown:setText(newTimeFormat(timeLeft))
    widget.cooldown:setColor('#f29257')
  else
    widget.cooldown:setText("No Cooldown")
    widget.cooldown:setColor('#b8b8b8')
  end
end
 
for bossName, dueTime in pairs(storage.analyzers.trackedBoss) do
  createBossPanel(bossName, dueTime)
end
 
local bossRegex = [[You (?:can|may) challenge ([\w\W]*) again in ([\d]*)]]
onTalk(function(name, level, mode, text, channelId, pos)
  if mode == 34 then
    local re = regexMatch(text, bossRegex)
    local name = re and re[1] and re[1][2]
    local cd = re and re[1] and re[1][3]
 
    for i=1,#BOSSES do
      local bad = BOSSES[i][1]
      local good = BOSSES[i][2]
 
      if name == bad then
        name = good
      end
    end
 
    if not cd then return end
 
    cd = tonumber(cd) * 60 * 60 -- cd in seconds
 
    storage.analyzers.trackedBoss[name] = os.time() + cd
    createBossPanel(name, os.time() + cd)
  end
end)
 
-- save outfits
onAttackingCreatureChange(function(newCreature, oldCreature)
  local name = newCreature and newCreature:getName()
  local outfit = newCreature and newCreature:getOutfit()
 
  if name then
    storage.analyzers.outfits[name] = storage.analyzers.outfits[name] or outfit
  end
end)
 
--stats window
local totalRounds = UI.DualLabel("Total Rounds:", "0", {}, statsWindow.contentsPanel).right
local avRoundTime = UI.DualLabel("Time by Round:", "00:00h", {}, statsWindow.contentsPanel).right
UI.Separator(statsWindow.contentsPanel)
local totalRefills = UI.DualLabel("Total Refills:", "0", {}, statsWindow.contentsPanel).right
local avRefillTime = UI.DualLabel("Time by Refill:", "00:00h", {}, statsWindow.contentsPanel).right
local lastRefill = UI.DualLabel("Time since Refill:", "00:00h", {maxWidth = 200}, statsWindow.contentsPanel).right
UI.Separator(statsWindow.contentsPanel)
local label = UI.DualLabel("Supplies by Round:", "", {maxWidth = 200}, statsWindow.contentsPanel).left
label:setColor('#EC9706')
local suppliesByRound = UI.createWidget("AnalyzerItemsPanel", statsWindow.contentsPanel)
UI.Separator(statsWindow.contentsPanel)
label = UI.DualLabel("Supplies by Refill:", "", {maxWidth = 200}, statsWindow.contentsPanel).left
label:setColor('#ED7117')
local suppliesByRefill = UI.createWidget("AnalyzerItemsPanel", statsWindow.contentsPanel)
UI.Separator(statsWindow.contentsPanel)
 
 
--huntig
local sessionTimeLabel = UI.DualLabel("Session:", "00:00h", {}, huntingWindow.contentsPanel).right
local xpGainLabel = UI.DualLabel("XP Gain:", "0", {}, huntingWindow.contentsPanel).right
local xpHourLabel = UI.DualLabel("XP/h:", "0", {}, huntingWindow.contentsPanel).right
local lootLabel = UI.DualLabel("Loot:", "0", {}, huntingWindow.contentsPanel).right
local suppliesLabel = UI.DualLabel("Supplies:", "0", {}, huntingWindow.contentsPanel).right
local balanceLabel = UI.DualLabel("Balance:", "0", {}, huntingWindow.contentsPanel).right
local damageLabel = UI.DualLabel("Damage:", "0", {}, huntingWindow.contentsPanel).right
local damageHourLabel = UI.DualLabel("Damage/h:", "0", {}, huntingWindow.contentsPanel).right
local healingLabel = UI.DualLabel("Healing:", "0", {}, huntingWindow.contentsPanel).right
local healingHourLabel = UI.DualLabel("Healing/h:", "0", {}, huntingWindow.contentsPanel).right
UI.DualLabel("Killed Monsters:", "", {maxWidth = 200}, huntingWindow.contentsPanel)
local killedList = UI.createWidget("AnalyzerListPanel", huntingWindow.contentsPanel)
UI.DualLabel("Looted items:", "", {maxWidth = 200}, huntingWindow.contentsPanel)
local lootList = UI.createWidget("AnalyzerListPanel", huntingWindow.contentsPanel)
 
 
--party
UI.Button("Copy to Clipboard", function() clipboardData() end, partyHuntWindow.contentsPanel)
UI.Button("Reset Sessions", function()
  if BotServer._websocket then
    BotServer.send("partyHunt", false)
  end
end, partyHuntWindow.contentsPanel)
 
local switch = addSwitch("sendData", "Send Analyzer Data", function(widget)
  widget:setOn(not widget:isOn())
  storage.sendPartyAnalyzerData = widget:isOn()
end, partyHuntWindow.contentsPanel)
switch:setOn(storage.sendPartyAnalyzerData)
UI.Separator(partyHuntWindow.contentsPanel)
local partySessionTimeLabel = UI.DualLabel("Session:", "00:00h", {}, partyHuntWindow.contentsPanel).right
local partyLootLabel = UI.DualLabel("Loot:", "0", {}, partyHuntWindow.contentsPanel).right
local partySuppliesLabel = UI.DualLabel("Supplies:", "0", {}, partyHuntWindow.contentsPanel).right
local partyBalanceLabel = UI.DualLabel("Balance:", "0", {}, partyHuntWindow.contentsPanel).right
UI.Separator(partyHuntWindow.contentsPanel)
 
local function maintainDropTable()
  local panel = dropTrackerWindow.contentsPanel
 
  for k,v in pairs(trackedLoot) do
    local widget = panel[k]
    if not widget then
      trackedLoot[k] = nil
    end
  end
end
 
local function createTrackedItems()
  local panel = dropTrackerWindow.contentsPanel
 
  for i, child in ipairs(panel:getChildren()) do
    if i > 2 then
      child:destroy()
    end
  end
 
  for k,v in pairs(trackedLoot) do
    local dropLoot = UI.createWidget("TrackerItem", dropTrackerWindow.contentsPanel)
    local item = dropLoot.item
    local name = dropLoot.name
    local drops = dropLoot.drops
    local id = tonumber(k)
    local itemName = id == 3031 and "gold coin" or id == 3035 and "platinum coin" or id == 3043 and "crystal coin" or Item.create(id):getMarketData().name
 
    dropLoot:setId(id)
    item:setItemId(id)
    if item:getItemCount() > 1 then
      item:setItemCount(1)
    end
    name:setText(itemName)
    drops:setText("Loot Drops: "..v)
 
    dropLoot.onDoubleClick = function()
      local id = dropLoot.item:getItemId()
      trackedLoot[tostring(id)] = 0
      drops:setText("Loot Drops: 0")
    end
  
    for i, child in pairs(dropLoot:getChildren()) do
      child:setTooltip("Double click to reset or clear item to remove.")
    end
 
    item.onItemChange = function(widget)
      local id = widget:getItemId()
      if id == 0 then 
        trackedLoot[widget:getParent():getId()] = nil
        if tonumber(widget:getParent():getId()) then
          widget:getParent():destroy()
          return
        end
        widget:setImageSource('/images/ui/item')
        widget:getParent():setId("blank")
        name:setText("Set Item to start track.")
        drops:setText("Loot Drops: 0")
        return 
      end
 
    -- only amount have changed, ignore
      if tonumber(widget:getParent():getId()) == id then return end
      local itemName = id == 3031 and "gold coin" or id == 3035 and "platinum coin" or id == 3043 and "crystal coin" or Item.create(id):getMarketData().name
 
      if trackedLoot[tostring(id)] then
        warn("vBot[Drop Tracker]: Item already added!")
        name:setText("Set Item to start track.")
        widget:setItemId(0)
        return 
      end
  
      widget:setImageSource('')
      drops:setText("Loot Drops: 0")
      name:setText(itemName)
      trackedLoot[tostring(id)] = trackedLoot[tostring(id)] or 0
      widget:getParent():setId(id)
      maintainDropTable()
    end
  end
end
 
--drop tracker
UI.Button("Add item to track drops", function()
  local dropLoot = UI.createWidget("TrackerItem", dropTrackerWindow.contentsPanel)
  local item = dropLoot.item
  local name = dropLoot.name
  local drops = dropLoot.drops
 
  item:setImageSource('/images/ui/item')
 
  dropLoot.onDoubleClick = function()
    local id = dropLoot.item:getItemId()
    trackedLoot[tostring(id)] = 0
    drops:setText("Loot Drops: 0")
  end
 
  for i, child in pairs(dropLoot:getChildren()) do
    child:setTooltip("Double click to reset or clear item to remove.")
  end
 
  item.onItemChange = function(widget)
    local id = widget:getItemId()
 
    if id == 0 then 
      trackedLoot[widget:getParent():getId()] = nil
      if tonumber(widget:getParent():getId()) then
        widget:getParent():destroy()
        return
      end
      widget:setImageSource('/images/ui/item')
      widget:getParent():setId("blank")
      name:setText("Set Item to start track.")
      drops:setText("Loot Drops: 0")
      return 
    end
 
    -- only amount have changed, ignore
    if tonumber(widget:getParent():getId()) == id then return end
    local itemName = id == 3031 and "gold coin" or id == 3035 and "platinum coin" or id == 3043 and "crystal coin" or Item.create(id):getMarketData().name
 
    if trackedLoot[tostring(id)] then
      warn("vBot[Drop Tracker]: Item already added!")
      name:setText("Set Item to start track.")
      widget:setItemId(0)
      return 
    end
 
    widget:setImageSource('')
    drops:setText("Loot Drops: 0")
    name:setText(itemName)
    trackedLoot[tostring(id)] = trackedLoot[tostring(id)] or 0
    widget:getParent():setId(id)
    maintainDropTable()
  end
end, dropTrackerWindow.contentsPanel)
 
UI.Separator(dropTrackerWindow.contentsPanel)
createTrackedItems()
 
 
--loot
local lootInLootAnalyzerLabel = UI.DualLabel("Gold Value:", "0", {}, lootWindow.contentsPanel).right
local lootHourInLootAnalyzerLabel = UI.DualLabel("Per Hour:", "0", {}, lootWindow.contentsPanel).right
UI.Separator(lootWindow.contentsPanel)
--//items panel
local lootItems = UI.createWidget("AnalyzerItemsPanel", lootWindow.contentsPanel)
UI.Separator(lootWindow.contentsPanel)
--//graph
local lootGraph = UI.createWidget("AnalyzerGraph", lootWindow.contentsPanel)
      lootGraph:setTitle("Loot/h")
      drawGraph(lootGraph, 0)
 
 
 
 
--supplies
local suppliesInSuppliesAnalyzerLabel = UI.DualLabel("Gold Value:", "0", {}, supplyWindow.contentsPanel).right
local suppliesHourInSuppliesAnalyzerLabel = UI.DualLabel("Per Hour:", "0", {}, supplyWindow.contentsPanel).right
UI.Separator(supplyWindow.contentsPanel)
--//items panel
local supplyItems = UI.createWidget("AnalyzerItemsPanel", supplyWindow.contentsPanel)
UI.Separator(supplyWindow.contentsPanel)
--//graph
local supplyGraph = UI.createWidget("AnalyzerGraph", supplyWindow.contentsPanel)
      supplyGraph:setTitle("Waste/h")
      drawGraph(supplyGraph, 0)      
 
 
 
 
-- impact
 
--- damage
local title = UI.DualLabel("Damage", "", {}, impactWindow.contentsPanel).left
title:setColor('#E3242B')
local totalDamageLabel = UI.DualLabel("Total:", "0", {}, impactWindow.contentsPanel).right
local maxDpsLabel = UI.DualLabel("Max-DPS:", "0", {}, impactWindow.contentsPanel).right
local bestHitLabel = UI.DualLabel("All-Time High:", "0", {}, impactWindow.contentsPanel).right
UI.Separator(impactWindow.contentsPanel)
local dmgGraph = UI.createWidget("AnalyzerGraph", impactWindow.contentsPanel)
      dmgGraph:setTitle("DPS")
      drawGraph(dmgGraph, 0)
      
      
--- distribution 
UI.Separator(impactWindow.contentsPanel)
local title2 = UI.DualLabel("Damage Distribution", "", {maxWidth = 150}, impactWindow.contentsPanel).left
title2:setColor('#FABD02')
local top1 = UI.DualLabel("-", "0", {maxWidth = 200}, impactWindow.contentsPanel)
local top2 = UI.DualLabel("-", "0", {maxWidth = 200}, impactWindow.contentsPanel)
local top3 = UI.DualLabel("-", "0", {maxWidth = 200}, impactWindow.contentsPanel)
local top4 = UI.DualLabel("-", "0", {maxWidth = 200}, impactWindow.contentsPanel)
local top5 = UI.DualLabel("-", "0", {maxWidth = 200}, impactWindow.contentsPanel)
 
top1.left:setWidth(135)
top2.left:setWidth(135)
top3.left:setWidth(135)
top4.left:setWidth(135)
top5.left:setWidth(135)
 
 
--- healing
UI.Separator(impactWindow.contentsPanel)
local title3 = UI.DualLabel("Healing", "", {}, impactWindow.contentsPanel).left
title3:setColor('#03C04A')
local totalHealingLabel = UI.DualLabel("Total:", "0", {}, impactWindow.contentsPanel).right
local maxHpsLabel = UI.DualLabel("Max-HPS:", "0", {}, impactWindow.contentsPanel).right
local bestHealLabel = UI.DualLabel("All-Time High:", "0", {}, impactWindow.contentsPanel).right
UI.Separator(impactWindow.contentsPanel)
--//graph
local healGraph = UI.createWidget("AnalyzerGraph", impactWindow.contentsPanel)
      healGraph:setTitle("HPS")
      drawGraph(healGraph, 0)  
 
 
 
 
 
 
 
--xp
local xpGrainInXpLabel = UI.DualLabel("XP Gain:", "0", {}, xpWindow.contentsPanel).right
local xpHourInXpLabel = UI.DualLabel("XP/h:", "0", {}, xpWindow.contentsPanel).right
local nextLevelLabel = UI.DualLabel("Next Level:", "-", {}, xpWindow.contentsPanel).right
local progressBar = UI.createWidget("AnalyzerProgressBar", xpWindow.contentsPanel)
progressBar:setPercent(modules.game_skills.skillsWindow.contentsPanel.level.percent:getPercent())
UI.Separator(xpWindow.contentsPanel)
--//graph
local xpGraph = UI.createWidget("AnalyzerGraph", xpWindow.contentsPanel)
      xpGraph:setTitle("XP/h")
      drawGraph(xpGraph, 0)
      
 
 
 
 
--#############################################
--#############################################   UI DONE
--#############################################
--#############################################
--#############################################
--#############################################
 
setDefaultTab("Main")
-- first, the variables
 
local console = modules.game_console
local regex = [[ ([^,|^.]+)]]
local noData = {}
local data = {}
 
local function getColor(v)
    if v >= 10000000 then -- 10kk, red
        return "#FF0000" 
    elseif v >= 5000000 then -- 5kk, orange
        return "#FFA500"
    elseif v >= 1000000 then -- 1kk, yellow
        return "#FFFF00"
    elseif v >= 100000 then -- 100k, purple
        return "#F25AED"
    elseif v >= 10000 then -- 10k, blue
        return "#5F8DF7"
    elseif v >= 1000 then -- 1k, green
        return "#00FF00"
    elseif v >= 50 then
        return "#FFFFFF" -- 50gp, white
    else
      return "#aaaaaa" -- less than 100gp, grey
    end
end
 
local function formatStr(str)
    if string.starts(str, "a ") then
        str = str:sub(2, #str)
    elseif string.starts(str, "an ") then
      str = str:sub(3, #str)
    end
 
    local n = getFirstNumberInText(str)
    if n then
        str = string.split(str, tostring(n))[1]
        str = str:sub(1,#str-1)
    end
 
    return str:trim()
end
 
local function getPrice(name)
    name = formatStr(name)
    name = name:lower()
    -- first check custom prices
    if storage.analyzers.customPrices[name] then
      return storage.analyzers.customPrices[name]
    end
 
    -- if already checked and no data skip looping items.lua
    if noData[name] then
        return 0
    end
 
    -- maybe was already checked, if so, skip looping items.lua
    if data[name] then
        return data[name]
    end
 
    -- searching in items.lua - big table, if possible skip
    for k,v in pairs(LootItems) do
        if name == k then
            data[name] = v
            return v
        end
    end
 
    -- if no data, save it and return 0
    noData[name] = true
    return 0
end
 
local expGained = function()
  return exp() - startExp
end
 
function format_thousand(v, comma)
  comma = comma and "," or "."
  if not v then return 0 end
  local s = string.format("%d", math.floor(v))
  local pos = string.len(s) % 3
  if pos == 0 then pos = 3 end
  return string.sub(s, 1, pos)
  .. string.gsub(string.sub(s, pos+1), "(...)", comma.."%1")
end
 
local expLeft = function()
  local level = lvl()+1
  return math.floor((50*level*level*level)/3 - 100*level*level + (850*level)/3 - 200) - exp()
end
 
niceTimeFormat = function(v, seconds) -- v in seconds
  local hours = string.format("%02.f", math.floor(v/3600))
  local mins = string.format("%02.f", math.floor(v/60 - (hours*60)))
  local secs = string.format("%02.f", math.floor(math.fmod(v, 60)))
 
  local final = string.format('%s:%s%s',hours,mins,seconds and ":"..secs or "")
 return final
end
local uptime
sessionTime = function()
  uptime = math.floor((now - launchTime)/1000)
  return niceTimeFormat(uptime)
end
sessionTime()
 
local expPerHour = function(calculation)
  local r = 0
  if #expTable > 0 then
      r = exp() - expTable[1]
  else
      return "-"
  end
 
  if uptime < 15*60 then
      r = math.ceil((r/uptime)*60*60)
  else
      r = math.ceil(r*8)
  end
  if calculation then
      return r
  else
      return format_thousand(r)
  end
end
 
local function add(t, text, color, last)
    table.insert(t, text)
    table.insert(t, color)
    if not last then
        table.insert(t, ", ")
        table.insert(t, "#FFFFFF")
    end
end
 
-- Bot Server
local function sendData()
  if BotServer._websocket then
    local totalDmg, totalHeal, lootWorth, wasteWorth, balance = getHuntingData()
    local outfit = player:getOutfit()
    outfit.mount = 0
    local t = {
      totalDmg, 
      totalHeal, 
      balance, 
      hppercent(), 
      manapercent(), 
      outfit, 
      player:isPartyLeader(), 
      lootWorth, 
      wasteWorth,
      modules.game_skills.skillsWindow.contentsPanel.stamina.value:getText(),
      format_thousand(expGained()),
      expPerHour(),
      balanceDesc .. " (" .. hourDesc .. ")",
      sessionTime()
    }
 
    -- validation
    if lastDataSend.totalDmg ~= t[1] and lastDataSend.totalHeal ~= t[2] then
      BotServer.send("partyHunt", t)
      lastDataSend[1] = t[1]
      lastDataSend[2] = t[2]
    end
  end
end
 
-- process data
if BotServer._websocket then
  BotServer.listen("partyHunt", function(name, message)
    if message == true then
      sendData()
    elseif message == false then
      resetAnalyzerSessionData()
    else
      membersData[name] = {
        damage = message[1], 
        heal = message[2], 
        balance = message[3], 
        hp = message[4], 
        mana = message[5], 
        outfit = message[6], 
        leader = message[7], 
        loot = message[8], 
        waste = message[9],
        stamina = message[10],
        expGained = message[11],
        expH = message[12],
        balanceH = message[13],
        session = message[14]
      }
 
      local widgetName = "Widget"..name
      local widget = partyHuntWindow.contentsPanel[widgetName] or UI.createWidget("MemberWidget", partyHuntWindow.contentsPanel)
      widget:setId(widgetName)
      widget.lastUpdate = now
 
 
      local t = membersData[name]
      widget.name:setText(name)
      widget.name:setColor("white")
      if t.leader then
        widget.name:setColor('#f8db38')
      end
      schedule(10*1000, function()
        if widget and widget.lastUpdate and now - widget.lastUpdate > 10000 then
          widget.name:setText(widget.name:getText().. " [inactive]")
          widget.name:setColor("#aeaeae")
          widget.health:setBackgroundColor("#aeaeae")
          widget.mana:setBackgroundColor("#aeaeae")
          widget.balance.value:setText("-")
          widget.damage.value:setText("-")
          widget.healing.value:setText("-")
          widget.creature:disable()
        end
      end)
      widget.creature:setOutfit(t.outfit)
      widget.health:setPercent(t.hp)
      widget.health:setBackgroundColor("#00c000")
      widget.mana:setPercent(t.mana)
      widget.mana:setBackgroundColor("#0000FF")
      widget.balance.value:setText(format_thousand(t.balance))
      if t.balance < 0 then
        widget.balance.value:setColor('#ff9854')
      elseif t.balance > 0 then
        widget.balance.value:setColor('#45ad25')
      else
        widget.balance.value:setColor('white')
      end
      widget.damage.value:setText(format_thousand(t.damage))
      widget.healing.value:setText(format_thousand(t.heal))
 
      widget.onDoubleClick = function()
        membersData[name] = nil
        widget:destroy()
      end
 
      --tooltip
      local tooltip = "Session: "..t.session.."\n"..
                      "Stamina: "..t.stamina.."\n"..
                      "Exp Gained: "..t.expGained.."\n"..
                      "Exp per Hour: "..t.expH.."\n"..
                      "Balance: "..t.balanceH
 
      widget.creature:setTooltip(tooltip)
    end
  end)
end
 
 
function hightlightText(widget, color, duration)
  for i=0,duration do
    schedule(i * 250, function()
      if i == duration or (i > 0 and i % 2 == 0) then
        widget:setColor("#FFFFFF")
      else
        widget:setColor(color)
      end
    end)
  end
end
 
local nameRegex = [[Loot of (?:an |a |the |)([^:]+)]]
onTextMessage(function(mode, text)
    if not storage.analyzers.lootChannel then return end
    if not text:find("Loot of") and not text:find("The following items are available in your reward chest") then return end
    local name
 
    -- adding monster to killed list
    if text:find("Loot of") then
      name = regexMatch(text, nameRegex)[1][2]
      if not killList[name] then
        killList[name] = 1
      else
        killList[name] = killList[name] + 1
      end
      refreshKills()
    end
    -- variables
    local split = string.split(text, ":")
    local re = regexMatch(split[2], regex)
    local combinedWorth = 0
    local formatted
    local div
    local t = {}
    local messageT = {}
 
    -- add timestamp, creature part and color it as white
    add(t, os.date('%H:%M') .. ' ' .. split[1]..": ", "#FFFFFF", true)
    add(messageT, split[1]..": ", "#FFFFFF", true)    
 
    -- main part
    if re ~= 0 then
        for i=1,#re do
            local data = re[i][2] -- each looted item
            local formattedLoot = regexMatch(data, [[(^[^(]+)]])[1][1]
            formattedLoot = formattedLoot:trim()
            local amount = getFirstNumberInText(formattedLoot) -- amount found in data
            local price = amount and getPrice(formattedLoot) * amount or getPrice(formattedLoot) -- if amount then multity price, else just take price
            local color = getColor(price) -- generate hex string based off price
            local messageColor = getColor(getPrice(formattedLoot))
 
            combinedWorth = combinedWorth + price -- add all prices to calculate total worth
 
            add(t, data, color, i==#re)
            add(messageT, data, color, i==#re)
 
            --drop tracker
            for i, child in ipairs(dropTrackerWindow.contentsPanel:getChildren()) do
              local childName = child.name
              childName = childName and childName:getText()
 
 
              if childName and formattedLoot:find(childName) then
                trackedLoot[tostring(child.item:getItemId())] = trackedLoot[tostring(child.item:getItemId())] + (amount or 1)
                child.drops:setText("Loot Drops: "..trackedLoot[tostring(child.item:getItemId())])
 
                hightlightText(child.name,"#f0b400", 8)
                modules.game_textmessage.messagesPanel.statusLabel:setVisible(true)
                modules.game_textmessage.messagesPanel.statusLabel:setColoredText({
                  "Valuable loot: ", "#f0b400",
                  childName.."", messageColor,
                  " dropped by "..name.."!", "#f0b400"
                })
                schedule(3000, function()
                  modules.game_textmessage.messagesPanel.statusLabel:setVisible(false)
                end)
              end
            end
        end
    end
 
    -- format total worth so it wont look obnoxious
    if combinedWorth >= 1000000 then
        div = combinedWorth/1000000
        formatted = math.floor(div) .. "." .. math.floor(div * 10) % 10 .. "kk"
    elseif combinedWorth >= 1000 then
        div = combinedWorth/1000
        formatted = math.floor(div) .. "." .. math.floor(div * 10) % 10 .. "k"
    else
        formatted = combinedWorth .. "gp"
    end
 
    if modules.game_textmessage.messagesPanel.centerTextMessagePanel.highCenterLabel:getText() == text then
      modules.game_textmessage.messagesPanel.centerTextMessagePanel.highCenterLabel:setColoredText(messageT)
      schedule(math.max(#text * 50, 2000), function() 
        modules.game_textmessage.messagesPanel.centerTextMessagePanel.highCenterLabel:setVisible(false)
      end)
    end
 
    -- add total worth to string
    add(t, " - (", "#FFFFFF", true)
    add(t, formatted, getColor(combinedWorth), true)
    add(t, ")", "#FFFFFF", true)
 
    -- get/create tab and write raw message
    local tabName = "vBot Loot"
    local tab = console.getTab(tabName) or console.addTab(tabName, true)
    console.addText(text, console.SpeakTypesSettings, tabName, "")
 
    -- find last message in given tab and rewrite it with formatted string
    local panel = console.consoleTabBar:getTabPanel(tab)
    local consoleBuffer = panel:getChildById('consoleBuffer')
    local message = consoleBuffer:getLastChild()
    message:setColoredText(t)
end)
 
local function niceFormat(v)
  local div
  local formatted
    if v >= 10000000 then
      div = v/10000000
      formatted = math.ceil(div) .. "M"
    elseif v >= 1000000 then
      div = v/1000000
      formatted = math.floor(div) .. "." .. math.floor(div * 10) % 10 .. "M"
    elseif v >= 10000 then
      div = v/1000
      formatted = math.floor(div) .. "k"
    elseif v >= 1000 then
        div = v/1000
        formatted = math.floor(div) .. "." .. math.floor(div * 10) % 10 .. "k"
    else
        formatted = v
    end
    return formatted
end
 
resetAnalyzerSessionData = function()
    vBot.CaveBotData = vBot.CaveBotData or {
      refills = 0,
      rounds = 0,
      time = {},
      lastRefill = os.time(),
      refillTime = {}
    }
    launchTime = now
    startExp = exp()
    dmgTable = {}
    healTable = {}
    expTable = {}
    totalDmg = 0
    totalHeal = 0
    dmgDistribution = {}
    first = {l="-", r="0"}
    second = {l="-", r="0"}
    third = {l="-", r="0"}
    fourth = {l="-", r="0"}
    five = {l="-", r="0"}
    lootedItems = {}
    useData = {}
    usedItems ={}
    refreshLoot()
    refreshWaste()
    xpGraph:clear()
    drawGraph(xpGraph, 0)
    lootGraph:clear()
    drawGraph(lootGraph, 0)
    supplyGraph:clear()
    drawGraph(supplyGraph, 0)
    dmgGraph:clear()
    drawGraph(dmgGraph, 0)
    healGraph:clear()
    drawGraph(healGraph, 0)
    killList = {}
    refreshKills()
    HuntingSessionStart = os.date('%Y-%m-%d, %H:%M:%S')
end
 
mainWindow.contentsPanel.ResetSession.onClick = function()
  resetAnalyzerSessionData()
end
 
mainWindow.contentsPanel.Settings.onClick = function()
  settingsWindow:show()
  settingsWindow:raise()
  settingsWindow:focus()
end
  
 
-- extras window
settingsWindow.closeButton.onClick = function()
  settingsWindow:hide()
end
 
local function getFrame(v)
  if v >= 1000000 then
      return '/images/ui/rarity_gold'
  elseif v >= 100000 then
      return '/images/ui/rarity_purple'
  elseif v >= 10000 then
      return '/images/ui/rarity_blue'
  elseif v >= 1000 then
      return '/images/ui/rarity_green'
  else
      return '/images/ui/item'
  end
end
 
 
displayCondition = function(menuPosition, lookThing, useThing, creatureThing)
  if lookThing and not lookThing:isCreature() and not lookThing:isNotMoveable() and lookThing:isPickupable() then
    return true
  end
end
local interface = modules.game_interface
 
local function setFrames()
  if not storage.analyzers.rarityFrames then return end
  for _, container in pairs(getContainers()) do
      local window = container.itemsPanel
      for i, child in pairs(window:getChildren()) do
          local id = child:getItemId()
          local price = 0
 
          if id ~= 0 then -- there's item
              local item = Item.create(id)
              local name = item:getMarketData().name:lower()
              price = getPrice(name)
 
              -- set rarity frame
              child:setImageSource(getFrame(price))
          else -- empty widget
              -- revert any possible changes
              child:setImageSource("/images/ui/item")
          end
          child.onHoverChange = function(widget, hovered)
            if id == 0 or not hovered then
              return interface.removeMenuHook('analyzer')
            end
            interface.addMenuHook('analyzer', 'Price:', function() end, displayCondition, price)          
        end
      end
  end 
end 
setFrames()
 
onContainerOpen(function(container, previousContainer)
  setFrames()
end)
 
onAddItem(function(container, slot, item, oldItem)
  setFrames()
end)
 
onRemoveItem(function(container, slot, item)
  setFrames()
end)
 
onContainerUpdateItem(function(container, slot, item, oldItem)
  setFrames()
end)
 
function smallNumbers(n)
  if n >= 10 ^ 6 then
      return string.format("%.1fkk", n / 10 ^ 6)
  elseif n >= 10 ^ 3 then
      return string.format("%.1fk", n / 10 ^ 3)
  else
      return tostring(n)
  end
end
 
function refreshList()
  local list = settingsWindow.CustomPrices
  list:destroyChildren()
 
  for name, price in pairs(storage.analyzers.customPrices) do
    local label = UI.createWidget("AnalyzerPriceLabel", list)
    label.remove.onClick = function()
      storage.analyzers.customPrices[name] = nil
      label:destroy()
      schedule(5, function()
        setFrames()
      end)
    end
    label:setText("["..name.."] = "..smallNumbers(price).." gp")
  end
end
refreshList()
 
settingsWindow.addItem.onClick = function()
  local newPrices = storage.analyzers.customPrices
  local id = settingsWindow.ID:getItemId()
  local newPrice = tonumber(settingsWindow.NewPrice:getText())
 
  if id < 100 then
    return warn("No item added!")
  end
 
  local name = Item.create(id):getMarketData().name
 
  if newPrices[name] then
    return warn("Item already added! Remove it from the list to set a new price!")
  end
 
  newPrices[name] = newPrice
  settingsWindow.ID:setItemId(0)
  settingsWindow.NewPrice:setText(0)
  schedule(5, function()
    setFrames()
  end)
  refreshList()
end
 
settingsWindow.LootChannel:setOn(storage.analyzers.lootChannel)
settingsWindow.LootChannel.onClick = function(widget)
  storage.analyzers.lootChannel = not storage.analyzers.lootChannel
  widget:setOn(storage.analyzers.lootChannel)
end
 
settingsWindow.RarityFrames:setOn(storage.analyzers.rarityFrames)
settingsWindow.RarityFrames.onClick = function(widget)
  storage.analyzers.rarityFrames = not storage.analyzers.rarityFrames
  widget:setOn(storage.analyzers.rarityFrames)
  setFrames()
end
 
local timeToLevel = function()
    local t = 0
    if expPerHour(true) == 0 or expPerHour() == "-" then
        return "-"
    else
        t = expLeft()/expPerHour(true)
        return niceTimeFormat(math.ceil(t*60*60))
    end
end
 
local sumT = function(t)
    local s = 0
    for i,v in pairs(t) do
        s = s + v.d
    end
    return s
end
 
local valueInSeconds = function(t)
    local d = 0
    local time = 0
    if #t > 0 then
        for i, v in ipairs(t) do
            if now - v.t <= 3000 then
                if time == 0 then
                    time = v.t
                end
                d = d + v.d
            else
              table.remove(t, 1)
            end
        end
    end
    return math.ceil(d/((now-time)/1000))
end
 
local regex = "You lose ([0-9]*) hitpoints due to an attack by ([a-z]*) ([a-z A-z-]*)" 
onTextMessage(function(mode, text)
  local value = getFirstNumberInText(text)
    if mode == 21 then -- damage dealt
      totalDmg = totalDmg + value
        table.insert(dmgTable, {d = value, t = now})
        if value > storage.bestHit then
            storage.bestHit = value
        end
    end
    if mode == 23 then -- healing
      totalHeal = totalHeal + value
        table.insert(healTable, {d = value, t = now})
        if value > storage.bestHeal then
            storage.bestHeal = value
        end
    end
 
    -- damage distribution part
    if text:find("You lose") then
      local data = regexMatch(text, regex)[1]
      if data then
        local monster = data[4]
        local val = data[2]
        table.insert(dmgDistribution, {v=val,m=monster,t=now})
      end
    end
end)
 
function capitalFistLetter(str)
  return (string.gsub(str, "^%l", string.upper))
end
 
-- tables maintance
macro(500, function()
  local dmgFinal = {}
  local labelTable = {}
  local dmgSum = 0
    table.insert(expTable, exp())
    if #expTable > 15*60 then
        for i,v in pairs(expTable) do
            if i == 1 then
              table.remove(expTable, i)
            end
        end
    end
 
    for i,v in pairs(dmgDistribution) do
      if now - v.t > 60*1000*10 then
        table.remove(dmgDistribution, i)
      else
        dmgSum = dmgSum + v.v
        if not dmgFinal[v.m] then
          dmgFinal[v.m] = v.v
        else
          dmgFinal[v.m] = dmgFinal[v.m] + v.v
        end
      end
    end
 
    first = dmgFinal[1] or {l="-", r="0"}
    second = dmgFinal[2] or {l="-", r="0"}
    third = dmgFinal[3] or {l="-", r="0"}
    fourth = dmgFinal[4] or {l="-", r="0"}
    five = dmgFinal[5] or {l="-", r="0"}
 
    for k,v in pairs(dmgFinal) do
      table.insert(labelTable, {m=k, d=tonumber(v)})
    end
 
    table.sort(labelTable, function(a,b) return a.d > b.d end)
 
    for i,v in pairs(labelTable) do
      local val = math.floor((v.d/dmgSum)*100) .. "%"
      local words = string.split(v.m, " ")
      local name = ""
      for i, word in ipairs(words) do
        name = name .. " " .. capitalFistLetter(word)
      end
      name = name:len() < 20 and name or name:sub(1,17).."..."
      name = name:trim()..": "
      if i == 1 then
        first = {l=name, r=val}
      elseif i == 2 then
        second = {l=name, r=val}
      elseif i == 3 then
        third = {l=name, r=val}
      elseif i == 4 then
        fourth = {l=name, r=val}
      elseif i == 5 then
        five = {l=name, r=val}
      else
        break
      end
    end
end)
 
function getPanelHeight(panel)
 
  local elements = panel.List:getChildCount()
  if elements == 0 then
    return 0
  else
    local rows = math.ceil(elements/5)
    local height = rows * 35
    return height
  end
end
 
function refreshLoot()
 
    lootItems:destroyChildren()
    lootList:destroyChildren()
 
    for k,v in pairs(lootedItems) do
      local label1 = UI.createWidget("AnalyzerLootItem", lootItems)
      local price = v.count and getPrice(v.name) * v.count or getPrice(v.name)
 
      label1:setItemId(k)
      label1:setItemCount(50)
      label1:setShowCount(false)
      label1.count:setText(niceFormat(v.count))
      label1.count:setColor(getColor(price))
      local tooltipName = v.count > 1 and v.name.."s" or v.name
      label1:setTooltip(v.count .. "x " .. tooltipName .. " (Value: "..format_thousand(getPrice(v.name)).."gp, Sum: "..format_thousand(price).."gp)")
      --hunting window loot list
      local label2 = UI.createWidget("ListLabel", lootList)
      label2:setText(v.count .. "x " .. v.name)
    end
 
    if lootItems:getChildCount() == 0 then
      local label = UI.createWidget("ListLabel", lootList)
      label:setText("None")
    end
end
refreshLoot()
 
function refreshKills()
    killedList:destroyChildren()
    local kills = 0
    for k,v in pairs(killList) do
      kills = kills + 1
      local label = UI.createWidget("ListLabel", killedList)
      label:setText(v .. "x " .. k)
    end
 
    if kills == 0 then
      local label = UI.createWidget("ListLabel", killedList)
      label:setText("None")
    end
end
refreshKills()
 
function refreshWaste()
 
    supplyItems:destroyChildren()
    suppliesByRefill:destroyChildren()
    suppliesByRound:destroyChildren()
 
    local parents = {supplyItems, suppliesByRound, suppliesByRefill}    
 
    for k,v in pairs(usedItems) do
      for i=1,#parents do
        local amount = i == 1 and v.count or 
                       i == 2 and v.count/(vBot.CaveBotData.rounds + 1) or 
                       i == 3 and v.count/(vBot.CaveBotData.refills + 1)
        amount = math.floor(amount)
        local label1 = UI.createWidget("AnalyzerLootItem", parents[i])
        local price = amount and getPrice(v.name) * amount or getPrice(v.name)
 
        label1:setItemId(k)
        label1:setItemCount(50)
        label1:setShowCount(false)
        label1.count:setText(niceFormat(amount))
        label1.count:setColor(getColor(price))
        local tooltipName = amount > 1 and v.name.."s" or v.name
        label1:setTooltip(amount .. "x " .. tooltipName .. " (Value: "..format_thousand(getPrice(v.name)).."gp, Sum: "..format_thousand(price).."gp)")
      end
    end
end
 
-- loot analyzer
-- adding
local containers = CaveBot.GetLootContainers()
local lastCap = freecap()
onAddItem(function(container, slot, item, oldItem)
  if not table.find(containers, container:getContainerItem():getId()) then return end
  if isInPz() then return end
  if slot > 0 then return end 
  if freecap() >= lastCap then return end
  local name = item:getId()
  local tmpname = item:getId() == 3031 and "gold coin" or item:getId() == 3035 and "platinum coin" or item:getId() == 3043 and "crystal coin" or item:getMarketData().name
  if not lootedItems[name] then
    lootedItems[name] = { count = item:getCount(), name = tmpname }
  else
    lootedItems[name].count =  lootedItems[name].count + item:getCount()
  end
  lastCap = freecap()
  refreshLoot()
 
  -- drop tracker
end)
 
onContainerUpdateItem(function(container, slot, item, oldItem)
  if not table.find(containers, container:getContainerItem():getId()) then return end
  if not oldItem then return end
  if isInPz() then return end 
  if freecap() == lastCap then return end
  
  local tmpname = item:getId() == 3031 and "gold coin" or item:getId() == 3035 and "platinum coin" or item:getId() == 3043 and "crystal coin" or item:getMarketData().name
  local amount = item:getCount() - oldItem:getCount()
  if amount < 0 then
    return
  end
  local name = item:getId()
  if not lootedItems[name] then
      lootedItems[name] = { count = amount, name = tmpname }
  else
      lootedItems[name].count = lootedItems[name].count + amount
  end
  lastCap = freecap()
  refreshLoot()
end)
 
-- ammo
local ammo = {16143, 763, 761, 7365, 3448, 762, 21470, 7364, 14251, 3447, 3449, 15793, 25757, 774, 35901, 6528, 7363, 3450, 16141, 25758, 14252, 3446, 16142, 35902}
onContainerUpdateItem(function(container, slot, item, oldItem)
  local id = item:getId()
  if not table.find(ammo, id) then return end
  local newCount = item:getCount()
  local oldCount = oldItem:getCount()
  local name = item:getMarketData().name
 
  if oldCount - newCount == 1 then
    if not usedItems[id] then
      usedItems[id] = { count = 1, name = name}
    else
      usedItems[id].count = usedItems[id].count + 1
    end
    refreshWaste()
  end
end)
 
-- waste
local regex3 = [[\d ([a-z A-Z]*)s...]]
local lackOfData = {}
onTextMessage(function(mode, text)
  text = text:lower()
  if not text:find("using one of") then return end
 
  local amount = getFirstNumberInText(text)
  local re = regexMatch(text, regex3)
  local name = re[1][2]
  local id = WasteItems[name]
 
  if not id then
 
    if not lackOfData[name] then
      lackOfData[name] = true
      print("[Analyzer] no data for item: "..name.. "inside items.lua -> WasteItems")
    end
 
    return
  end
 
  if not useData[name] then
    useData[name] = amount
  else
    if math.abs(useData[name]-amount) == 1 then
      useData[name] = amount
      if not usedItems[id] then
        usedItems[id] = { count = 1, name = name}
      else
        usedItems[id].count = usedItems[id].count + 1
      end
    else
      useData[name] = amount
    end
    refreshWaste()
  end
end)
 
function hourVal(v)
  v = v or 0
  return (v/uptime)*3600
end
 
function bottingStats()
  lootWorth = 0
  wasteWorth = 0
  for k, v in pairs(lootedItems) do
    if LootItems[v.name] then
      lootWorth = lootWorth + (LootItems[v.name]*v.count)
    end
  end
  for k, v in pairs(usedItems) do
    if LootItems[v.name] then
      wasteWorth = wasteWorth + (LootItems[v.name]*v.count)
    end
  end
  balance = lootWorth - wasteWorth
 
  return lootWorth, wasteWorth, balance
end
 
function bottingLabels(lootWorth, wasteWorth, balance)
  balanceDesc = nil
  hourDesc = nil
  desc = nil
 
  if balance >= 1000000 or balance <= -1000000 then
    desc = balance / 1000000
    balanceDesc = math.floor(desc) .. "." .. math.floor(desc * 10) % 10 .. "kk"
  elseif balance >= 1000 or balance <= -1000 then
    desc = balance / 1000
    balanceDesc = math.floor(desc) .. "." .. math.floor(desc * 10) % 10 .."k"
  else
    balanceDesc = balance .. "gp"
  end
 
  hour = hourVal(balance)
  if hour >= 1000000 or hour <= -1000000 then
    desc = balance / 1000000
    hourDesc = math.floor(hourVal(desc)) .. "." .. math.floor(hourVal(desc) * 10) % 10 .. "kk/h"
  elseif hour >= 1000 or hour <= -1000 then
    desc = balance / 1000
    hourDesc = math.floor(hourVal(desc)) .. "." .. math.floor(hourVal(desc) * 10) % 10 .. "k/h"
  else
    hourDesc = math.floor(hourVal(balance)) .. "gp/h"
  end
 
  return balanceDesc, hourDesc
end
 
function reportStats()
  local lootWorth, wasteWorth, balance = bottingStats()
  local balanceDesc, hourDesc = bottingLabels(lootWorth, wasteWorth, balance)
 
  local a, b, c
 
  a = "Session Time: " .. sessionTime() .. ", Exp Gained: " .. format_thousand(expGained()) .. ", Exp/h: " .. expPerHour()
  b = " | Balance: " .. balanceDesc .. " (" .. hourDesc .. ")"
  c = a..b
 
  return c
end
 
function damageHour()
  if uptime < 5*60 then
    return totalDmg
  else
    return hourVal(totalDmg)
  end
end
 
function healHour()
  if uptime < 5*60 then
    return totalHeal
  else
    return hourVal(totalHeal)
  end
end
 
function wasteHour()
  local lootWorth, wasteWorth, balance = bottingStats()
  if uptime < 5*60 then
    return wasteWorth
  else
    return hourVal(wasteWorth)
  end
end
 
 
function lootHour()
  local lootWorth, wasteWorth, balance = bottingStats()
  if uptime < 5*60 then
    return lootWorth
  else
    return hourVal(lootWorth)
  end
end
 
function getHuntingData()
  local lootWorth, wasteWorth, balance = bottingStats()
  return totalDmg, totalHeal, lootWorth, wasteWorth, balance
end
 
function avgTable(t)
  if type(t) ~= 'table' then return 0 end
  local val = 0
 
  for i,v in pairs(t) do
    val = val + v
  end
 
  if #t == 0 then
    return 0
  else
    return val/#t
  end
end
 
--bestdps/hps
local bestDPS = 0
local bestHPS = 0
--main loop
macro(500, function()
    local lootWorth, wasteWorth, balance = bottingStats()
    local balanceDesc, hourDesc = bottingLabels(lootWorth, wasteWorth, balance)
 
    -- hps and dps
    local curHPS = valueInSeconds(healTable)
    local curDPS = valueInSeconds(dmgTable)
 
    bestHPS = bestHPS > curHPS and bestHPS or curHPS
    bestDPS = bestDPS > curDPS and bestDPS or curDPS
 
    --hunt window
    sessionTimeLabel:setText(sessionTime())
    xpGainLabel:setText(format_thousand(expGained()))
    xpHourLabel:setText(expPerHour())
    lootLabel:setText(format_thousand(lootWorth))
    suppliesLabel:setText(format_thousand(wasteWorth))
    balanceLabel:setColor(balance >= 0 and "#45ad25" or "#ff9854")
    balanceLabel:setText(balanceDesc .. " (" .. hourDesc .. ")")
    damageLabel:setText(format_thousand(totalDmg))
    damageHourLabel:setText(format_thousand(damageHour()))
    healingLabel:setText(format_thousand(totalHeal))
    healingHourLabel:setText(format_thousand(healHour()))
 
    --loot window
    lootInLootAnalyzerLabel:setText(format_thousand(lootWorth))
    lootHourInLootAnalyzerLabel:setText(format_thousand(lootHour()))
 
 
    --supply window
    suppliesInSuppliesAnalyzerLabel:setText(format_thousand(wasteWorth))
    suppliesHourInSuppliesAnalyzerLabel:setText(format_thousand(wasteHour()))
 
    --impact window
    totalDamageLabel:setText(format_thousand(totalDmg))
    maxDpsLabel:setText(format_thousand(bestDPS))
    bestHitLabel:setText(storage.bestHit)
 
    top1.left:setText(first.l)
    top1.right:setText(first.r)
    top2.left:setText(second.l)
    top2.right:setText(second.r)
    top3.left:setText(third.l)
    top3.right:setText(third.r)
    top4.left:setText(fourth.l)
    top4.right:setText(fourth.r)
    top5.left:setText(five.l)
    top5.right:setText(five.r)
 
    totalHealingLabel:setText(format_thousand(totalHeal))
    maxHpsLabel:setText(format_thousand(bestHPS))
    bestHealLabel:setText(storage.bestHeal)
 
    --xp window
    xpGrainInXpLabel:setText(format_thousand(expGained()))
    xpHourInXpLabel:setText(expPerHour())
    nextLevelLabel:setText(timeToLevel())
    progressBar:setPercent(modules.game_skills.skillsWindow.contentsPanel.level.percent:getPercent())
 
 
    --stats
    totalRounds:setText(vBot.CaveBotData.rounds)
    avRoundTime:setText(niceTimeFormat(avgTable(vBot.CaveBotData.time),true))
    totalRefills:setText(vBot.CaveBotData.refills)
    avRefillTime:setText(niceTimeFormat(avgTable(vBot.CaveBotData.refillTime),true))
    lastRefill:setText(niceTimeFormat(os.difftime(os.time()-vBot.CaveBotData.lastRefill),true))
 
end)
 
--graphs, draw each minute
macro(60*1000, function()
 
  drawGraph(xpGraph, expPerHour(true) or 0)
  drawGraph(lootGraph, lootHour() or 0)
  drawGraph(supplyGraph, wasteHour() or 0)
  drawGraph(dmgGraph, valueInSeconds(dmgTable) or 0)
  drawGraph(healGraph, valueInSeconds(healTable) or 0)
end)
 
--party hunt analyzer
macro(2000, function()
  if not BotServer._websocket then return end
 
  -- send data
  if storage.sendPartyAnalyzerData then
    sendData()
  end
 
  local totalWaste, totalLoot, totalBalance = getSumStats()
 
  partySessionTimeLabel:setText(sessionTime())
  partyLootLabel:setText(format_thousand(totalLoot))
  partySuppliesLabel:setText(format_thousand(totalWaste))
  partyBalanceLabel:setText(format_thousand(totalBalance))
 
  if totalBalance < 0 then
    partyBalanceLabel:setColor('#ff9854')
  elseif totalBalance > 0 then
    partyBalanceLabel:setColor('#45ad25')
  else
    partyBalanceLabel:setColor('white')
  end
 
  for bossName, dueTime in pairs(storage.analyzers.trackedBoss) do
    createBossPanel(bossName, dueTime)
  end
end)
 
-- public functions
-- global namespace
Analyzer = {}
 
Analyzer.getKillsAmount = function(name)
  return killList[name] or 0
end
 
Analyzer.getLootedAmount = function(nameOrId)
  if type(nameOrId) == "number" then
    return lootedItems[nameOrId].count or 0
  else
    local nameOrId = nameOrId:lower()
    for k,v in pairs(lootedItems) do
      if v.name == nameOrId then
        return v.count
      end
    end
  end
  return 0
end
 
Analyzer.getTotalProfit = function()
  local lootWorth, wasteWorth, balance = bottingStats()
 
  return lootWorth
end
 
Analyzer.getTotalWaste = function()
  local lootWorth, wasteWorth, balance = bottingStats()
 
  return wasteWorth
end
 
Analyzer.getBalance = function()
  local lootWorth, wasteWorth, balance = bottingStats()
 
  return balance
end
 
Analyzer.getXpGained = function()
  return expGained()
end
 
Analyzer.getXpHour = function()
  return expPerHour()
end
 
Analyzer.getTimeToNextLevel = function()
  return timeToLevel()
end
 
Analyzer.getCaveBotStats = function()
  local parents = {suppliesByRound, suppliesByRefill}
  local round = {}
  local refill = {}
  for i=1,2 do
    local data = parents[i]
    for j, child in ipairs(data:getChildren()) do
      local id = child:getItemId()
      local count = child.count
 
      if i == 1 then
        round[id] = count
      else
        refill[id] = count
      end
    end
  end
 
  return {
    totalRounds = totalRounds:getText(),
    avRoundTime = avRoundTime:getText(),
    totalRefills = totalRefills:getText(),
    avRefillTime = avRefillTime:getText(),
    lastRefill = lastRefill:getText(),
    roundSupplies = round, -- { [id] = amount, [id2] = amount ...}
    refillSupplies = refill -- { [id] = amount, [id2] = amount ...}
  }
end

-- Author: Vithrax
-- contains mostly basic function shortcuts and code shorteners

-- initial global variables declaration
vBot = {} -- global namespace for bot variables
vBot.BotServerMembers = {}
vBot.standTime = now
vBot.isUsingPotion = false
vBot.isUsing = false
vBot.customCooldowns = {}

function logInfo(text)
    local timestamp = os.date("%H:%M:%S")
    text = tostring(text)
    local start = timestamp.." [vBot]: "

    return modules.client_terminal.addLine(start..text, "orange") 
end

-- scripts / functions
onPlayerPositionChange(function(x,y)
    vBot.standTime = now
end)

function standTime()
    return now - vBot.standTime
end

function relogOnCharacter(charName)
    local characters = g_ui.getRootWidget().charactersWindow.characters
    for index, child in ipairs(characters:getChildren()) do
        local name = child:getChildren()[1]:getText()
    
        if name:lower():find(charName:lower()) then
            child:focus()
            schedule(100, modules.client_entergame.CharacterList.doLogin)
        end
    end
end

function castSpell(text)
    if canCast(text) then
        say(text)
    end
end

local dmgTable = {}
local lastDmgMessage = now
onTextMessage(function(mode, text)
    if not text:lower():find("you lose") or not text:lower():find("due to") then
        return
    end
    local dmg = string.match(text, "%d+")
    if #dmgTable > 0 then
        for k, v in ipairs(dmgTable) do
            if now - v.t > 3000 then table.remove(dmgTable, k) end
        end
    end
    lastDmgMessage = now
    table.insert(dmgTable, {d = dmg, t = now})
    schedule(3050, function()
        if now - lastDmgMessage > 3000 then dmgTable = {} end
    end)
end)

-- based on data collected by callback calculates per second damage
-- returns number
function burstDamageValue()
    local d = 0
    local time = 0
    if #dmgTable > 1 then
        for i, v in ipairs(dmgTable) do
            if i == 1 then time = v.t end
            d = d + v.d
        end
    end
    return math.ceil(d / ((now - time) / 1000))
end

-- simplified function from modules
-- displays string as white colour message
function whiteInfoMessage(text)
    return modules.game_textmessage.displayGameMessage(text)
end

function statusMessage(text, logInConsole)
    return not logInConsole and modules.game_textmessage.displayFailureMessage(text) or modules.game_textmessage.displayStatusMessage(text)
end

-- same as above but red message
function broadcastMessage(text)
    return modules.game_textmessage.displayBroadcastMessage(text)
end

-- almost every talk action inside cavebot has to be done by using schedule
-- therefore this is simplified function that doesn't require to build a body for schedule function
function scheduleNpcSay(text, delay)
    if not text or not delay then return false end

    return schedule(delay, function() NPC.say(text) end)
end

-- returns first number in string, already formatted as number
-- returns number or nil
function getFirstNumberInText(text)
    local n = nil
    if string.match(text, "%d+") then n = tonumber(string.match(text, "%d+")) end
    return n
end

-- function to search if item of given ID can be found on certain tile
-- first argument is always ID 
-- the rest of aguments can be:
-- - tile
-- - position
-- - or x,y,z coordinates as p1, p2 and p3
-- returns boolean
function isOnTile(id, p1, p2, p3)
    if not id then return end
    local tile
    if type(p1) == "table" then
        tile = g_map.getTile(p1)
    elseif type(p1) ~= "number" then
        tile = p1
    else
        local p = getPos(p1, p2, p3)
        tile = g_map.getTile(p)
    end
    if not tile then return end

    local item = false
    if #tile:getItems() ~= 0 then
        for i, v in ipairs(tile:getItems()) do
            if v:getId() == id then item = true end
        end
    else
        return false
    end

    return item
end

-- position is a special table, impossible to compare with normal one
-- this is translator from x,y,z to proper position value
-- returns position table
function getPos(x, y, z)
    if not x or not y or not z then return nil end
    local pos = pos()
    pos.x = x
    pos.y = y
    pos.z = z

    return pos
end

-- opens purse... that's it
function openPurse()
    return g_game.use(g_game.getLocalPlayer():getInventoryItem(
                          InventorySlotPurse))
end

-- check's whether container is full
-- c has to be container object
-- returns boolean
function containerIsFull(c)
    if not c then return false end

    if c:getCapacity() > #c:getItems() then
        return false
    else
        return true
    end

end

function dropItem(idOrObject)
    if type(idOrObject) == "number" then
        idOrObject = findItem(idOrObject)
    end

    g_game.move(idOrObject, pos(), idOrObject:getCount())
end

-- not perfect function to return whether character has utito tempo buff
-- known to be bugged if received debuff (ie. roshamuul)
-- TODO: simply a better version
-- returns boolean
function isBuffed()
    local var = false
    if not hasPartyBuff() then return var end

    local skillId = 0
    for i = 1, 4 do
        if player:getSkillBaseLevel(i) > player:getSkillBaseLevel(skillId) then
            skillId = i
        end
    end

    local premium = (player:getSkillLevel(skillId) - player:getSkillBaseLevel(skillId))
    local base = player:getSkillBaseLevel(skillId)
    if (premium / 100) * 305 > base then
        var = true
    end
    return var
end

-- if using index as table element, this can be used to properly assign new idex to all values
-- table needs to contain "index" as value
-- if no index in tables, it will create one
function reindexTable(t)
    if not t or type(t) ~= "table" then return end

    local i = 0
    for _, e in pairs(t) do
        i = i + 1
        e.index = i
    end
end

-- supports only new tibia, ver 10+
-- returns how many kills left to get next skull - can be red skull, can be black skull!
-- reutrns number
function killsToRs()
    return math.min(g_game.getUnjustifiedPoints().killsDayRemaining,
                    g_game.getUnjustifiedPoints().killsWeekRemaining,
                    g_game.getUnjustifiedPoints().killsMonthRemaining)
end

-- calculates exhaust for potions based on "Aaaah..." message
-- changes state of vBot variable, can be used in other scripts
-- already used in pushmax, healbot, etc

onTalk(function(name, level, mode, text, channelId, pos)
    if name ~= player:getName() then return end
    if mode ~= 34 then return end

    if text == "Aaaah..." then
        vBot.isUsingPotion = true
        schedule(950, function() vBot.isUsingPotion = false end)
    end
end)

-- [[ canCast and cast functions ]] --
-- callback connected to cast and canCast function
-- detects if a given spell was in fact casted based on player's text messages 
-- Cast text and message text must match
-- checks only spells inserted in SpellCastTable by function cast
SpellCastTable = {}
onTalk(function(name, level, mode, text, channelId, pos)
    if name ~= player:getName() then return end
    text = text:lower()

    if SpellCastTable[text] then SpellCastTable[text].t = now end
end)

-- if delay is nil or delay is lower than 100 then this function will act as a normal say function
-- checks or adds a spell to SpellCastTable and updates cast time if exist
function cast(text, delay)
    text = text:lower()
    if type(text) ~= "string" then return end
    if not delay or delay < 100 then
        return say(text) -- if not added delay or delay is really low then just treat it like casual say
    end
    if not SpellCastTable[text] or SpellCastTable[text].d ~= delay then
        SpellCastTable[text] = {t = now - delay, d = delay}
        return say(text)
    end
    local lastCast = SpellCastTable[text].t
    local spellDelay = SpellCastTable[text].d
    if now - lastCast > spellDelay then return say(text) end
end

-- canCast is a base for AttackBot and HealBot
-- checks if spell is ready to be casted again
-- ignoreRL - if true, aparat from cooldown will also check conditions inside gamelib SpellInfo table
-- ignoreCd - it true, will ignore cooldown
-- returns boolean
local Spells = modules.gamelib.SpellInfo['Default']
function canCast(spell, ignoreRL, ignoreCd)
    if type(spell) ~= "string" then return end
    spell = spell:lower()
    if SpellCastTable[spell] then
        if now - SpellCastTable[spell].t > SpellCastTable[spell].d or ignoreCd then
            return true
        else
            return false
        end
    end
    if getSpellData(spell) then
        if (ignoreCd or not getSpellCoolDown(spell)) and
            (ignoreRL or level() >= getSpellData(spell).level and mana() >=
                getSpellData(spell).mana) then
            return true
        else
            return false
        end
    end
    -- if no data nor spell table then return true
    return true
end

local lastPhrase = ""
onTalk(function(name, level, mode, text, channelId, pos)
    if name == player:getName() then
        lastPhrase = text:lower()
    end
end)

if onSpellCooldown and onGroupSpellCooldown then
    onSpellCooldown(function(iconId, duration)
        schedule(1, function()
            if not vBot.customCooldowns[lastPhrase] then
                vBot.customCooldowns[lastPhrase] = {id = iconId}
            end
        end)
    end)

    onGroupSpellCooldown(function(iconId, duration)
        schedule(2, function()
            if vBot.customCooldowns[lastPhrase] then
                vBot.customCooldowns[lastPhrase] = {id = vBot.customCooldowns[lastPhrase].id, group = {[iconId] = duration}}
            end
        end)
    end)
else
    warn("Client Antigo!")
end

-- exctracts data about spell from gamelib SpellInfo table
-- returns table
-- ie:['Spell Name'] = {id, words, exhaustion, premium, type, icon, mana, level, soul, group, vocations}
-- cooldown detection module
function getSpellData(spell)
    if not spell then return false end
    spell = spell:lower()
    local t = nil
    local c = nil
    for k, v in pairs(Spells) do
        if v.words == spell then
            t = k
            break
        end
    end
    if not t then
        for k, v in pairs(vBot.customCooldowns) do
            if k == spell then
                c = {id = v.id, mana = 1, level = 1, group = v.group}
                break
            end
        end
    end
    if t then
        return Spells[t]
    elseif c then
        return c
    else
        return false
    end
end

-- based on info extracted by getSpellData checks if spell is on cooldown
-- returns boolean
function getSpellCoolDown(text)
    if not text then return nil end
    text = text:lower()
    local data = getSpellData(text)
    if not data then return false end
    local icon = modules.game_cooldown.isCooldownIconActive(data.id)
    local group = false
    for groupId, duration in pairs(data.group) do
        if modules.game_cooldown.isGroupCooldownIconActive(groupId) then
            group = true
            break
        end
    end
    if icon or group then
        return true
    else
        return false
    end
end

-- global var to indicate that player is trying to do something
-- prevents action blocking by scripts
-- below callbacks are triggers to changing the var state
local isUsingTime = now
macro(100, function()
    vBot.isUsing = now < isUsingTime and true or false
end)
onUse(function(pos, itemId, stackPos, subType)
    if pos.x > 65000 then return end
    if getDistanceBetween(player:getPosition(), pos) > 1 then return end
    local tile = g_map.getTile(pos)
    if not tile then return end

    local topThing = tile:getTopUseThing()
    if topThing:isContainer() then return end

    isUsingTime = now + 1000
end)
onUseWith(function(pos, itemId, target, subType)
    if pos.x < 65000 then isUsingTime = now + 1000 end
end)

-- returns first word in string 
function string.starts(String, Start)
    return string.sub(String, 1, string.len(Start)) == Start
end

-- global tables for cached players to prevent unnecesary resource consumption
-- probably still can be improved, TODO in future
-- c can be creature or string
-- if exected then adds name or name and creature to tables
-- returns boolean
CachedFriends = {}
CachedEnemies = {}
function isFriend(c)
    local name = c
    if type(c) ~= "string" then
        if c == player then return true end
        name = c:getName()
    end

    if CachedFriends[c] then return true end
    if CachedEnemies[c] then return false end

    if table.find(storage.playerList.friendList, name) then
        CachedFriends[c] = true
        return true
    elseif vBot.BotServerMembers[name] ~= nil then
        CachedFriends[c] = true
        return true
    elseif storage.playerList.groupMembers then
        local p = c
        if type(c) == "string" then p = getCreatureByName(c, true) end
        if not p then return false end
        if p:isLocalPlayer() then return true end
        if p:isPlayer() then
            if p:isPartyMember() then
                CachedFriends[c] = true
                CachedFriends[p] = true
                return true
            end
        end
    else
        return false
    end
end

-- similar to isFriend but lighter version
-- accepts only name string
-- returns boolean
function isEnemy(c)
    local name = c
    local p
    if type(c) ~= "string" then
        if c == player then return false end
        name = c:getName()
        p = c
    end
    if not name then return false end
    if not p then
        p = getCreatureByName(name, true)
    end
    if not p then return end
    if p:isLocalPlayer() then return end

    if p:isPlayer() and table.find(storage.playerList.enemyList, name) or
        (storage.playerList.marks and not isFriend(name)) or p:getEmblem() == 2 then
        return true
    else
        return false
    end
end

function getPlayerDistribution()
    local friends = {}
    local neutrals = {}
    local enemies = {}
    for i, spec in ipairs(getSpectators()) do
        if spec:isPlayer() and not spec:isLocalPlayer() then
            if isFriend(spec) then
                table.insert(friends, spec)
            elseif isEnemy(spec) then
                table.insert(enemies, spec)
            else
                table.insert(neutrals, spec)
            end
        end
    end

    return friends, neutrals, enemies
end

function getFriends()
    local friends, neutrals, enemies = getPlayerDistribution()

    return friends
end

function getNeutrals()
    local friends, neutrals, enemies = getPlayerDistribution()

    return neutrals
end

function getEnemies()
    local friends, neutrals, enemies = getPlayerDistribution()

    return enemies
end

-- based on first word in string detects if text is a offensive spell
-- returns boolean
function isAttSpell(expr)
    if string.starts(expr, "exori") or string.starts(expr, "exevo") then
        return true
    else
        return false
    end
end

-- returns dressed-up item id based on not dressed id
-- returns number
function getActiveItemId(id)
    if not id then return false end

    if id == 3049 then
        return 3086
    elseif id == 3050 then
        return 3087
    elseif id == 3051 then
        return 3088
    elseif id == 3052 then
        return 3089
    elseif id == 3053 then
        return 3090
    elseif id == 3091 then
        return 3094
    elseif id == 3092 then
        return 3095
    elseif id == 3093 then
        return 3096
    elseif id == 3097 then
        return 3099
    elseif id == 3098 then
        return 3100
    elseif id == 16114 then
        return 16264
    elseif id == 23531 then
        return 23532
    elseif id == 23533 then
        return 23534
    elseif id == 23544 then
        return 23528
    elseif id == 23529 then
        return 23530
    elseif id == 30343 then -- Sleep Shawl
        return 30342
    elseif id == 30344 then -- Enchanted Pendulet
        return 30345
    elseif id == 30403 then -- Enchanted Theurgic Amulet
        return 30402
    elseif id == 31621 then -- Blister Ring
        return 31616
    elseif id == 32621 then -- Ring of Souls
        return 32635
    else
        return id
    end
end

-- returns not dressed item id based on dressed-up id
-- returns number
function getInactiveItemId(id)
    if not id then return false end

    if id == 3086 then
        return 3049
    elseif id == 3087 then
        return 3050
    elseif id == 3088 then
        return 3051
    elseif id == 3089 then
        return 3052
    elseif id == 3090 then
        return 3053
    elseif id == 3094 then
        return 3091
    elseif id == 3095 then
        return 3092
    elseif id == 3096 then
        return 3093
    elseif id == 3099 then
        return 3097
    elseif id == 3100 then
        return 3098
    elseif id == 16264 then
        return 16114
    elseif id == 23532 then
        return 23531
    elseif id == 23534 then
        return 23533
    elseif id == 23530 then
        return 23529
    elseif id == 30342 then -- Sleep Shawl
        return 30343
    elseif id == 30345 then -- Enchanted Pendulet
        return 30344
    elseif id == 30402 then -- Enchanted Theurgic Amulet
        return 30403
    elseif id == 31616 then -- Blister Ring
        return 31621
    elseif id == 32635 then -- Ring of Souls
        return 32621
    else
        return id
    end
end

-- returns amount of monsters within the range of position
-- does not include summons (new tibia)
-- returns number
function getMonstersInRange(pos, range)
    if not pos or not range then return false end
    local monsters = 0
    for i, spec in pairs(getSpectators()) do
        if spec:isMonster() and
            (g_game.getClientVersion() < 960 or spec:getType() < 3) and
            getDistanceBetween(pos, spec:getPosition()) < range then
            monsters = monsters + 1
        end
    end
    return monsters
end

-- shortcut in calculating distance from local player position
-- needs only one argument
-- returns number
function distanceFromPlayer(coords)
    if not coords then return false end
    return getDistanceBetween(pos(), coords)
end

-- returns amount of monsters within the range of local player position
-- does not include summons (new tibia)
-- can also check multiple floors
-- returns number
function getMonsters(range, multifloor)
    if not range then range = 10 end
    local mobs = 0;
    for _, spec in pairs(getSpectators(multifloor)) do
        mobs = (g_game.getClientVersion() < 960 or spec:getType() < 3) and
                   spec:isMonster() and distanceFromPlayer(spec:getPosition()) <=
                   range and mobs + 1 or mobs;
    end
    return mobs;
end

-- returns amount of players within the range of local player position
-- does not include party members
-- can also check multiple floors
-- returns number
function getPlayers(range, multifloor)
    if not range then range = 10 end
    local specs = 0;
    for _, spec in pairs(getSpectators(multifloor)) do
        if not spec:isLocalPlayer() and spec:isPlayer() and distanceFromPlayer(spec:getPosition()) <= range and not ((spec:getShield() ~= 1 and spec:isPartyMember()) or spec:getEmblem() == 1) then
            specs = specs + 1
        end
    end
    return specs;
end

-- this is multifloor function
-- checks if player added in "Anti RS list" in player list is within the given range
-- returns boolean
function isBlackListedPlayerInRange(range)
    if #storage.playerList.blackList == 0 then return end
    if not range then range = 10 end
    local found = false
    for _, spec in pairs(getSpectators(true)) do
        local specPos = spec:getPosition()
        local pPos = player:getPosition()
        if spec:isPlayer() then
            if math.abs(specPos.z - pPos.z) <= 2 then
                if specPos.z ~= pPos.z then specPos.z = pPos.z end
                if distanceFromPlayer(specPos) < range then
                    if table.find(storage.playerList.blackList, spec:getName()) then
                        found = true
                    end
                end
            end
        end
    end
    return found
end

-- checks if there is non-friend player withing the range
-- padding is only for multifloor
-- returns boolean
function isSafe(range, multifloor, padding)
    local onSame = 0
    local onAnother = 0
    if not multifloor and padding then
        multifloor = false
        padding = false
    end

    for _, spec in pairs(getSpectators(multifloor)) do
        if spec:isPlayer() and not spec:isLocalPlayer() and
            not isFriend(spec:getName()) then
            if spec:getPosition().z == posz() and
                distanceFromPlayer(spec:getPosition()) <= range then
                onSame = onSame + 1
            end
            if multifloor and padding and spec:getPosition().z ~= posz() and
                distanceFromPlayer(spec:getPosition()) <= (range + padding) then
                onAnother = onAnother + 1
            end
        end
    end

    if onSame + onAnother > 0 then
        return false
    else
        return true
    end
end

-- returns amount of players within the range of local player position
-- can also check multiple floors
-- returns number
function getAllPlayers(range, multifloor)
    if not range then range = 10 end
    local specs = 0;
    for _, spec in pairs(getSpectators(multifloor)) do
        specs = not spec:isLocalPlayer() and spec:isPlayer() and
                    distanceFromPlayer(spec:getPosition()) <= range and specs +
                    1 or specs;
    end
    return specs;
end

-- returns amount of NPC's within the range of local player position
-- can also check multiple floors
-- returns number
function getNpcs(range, multifloor)
    if not range then range = 10 end
    local npcs = 0;
    for _, spec in pairs(getSpectators(multifloor)) do
        npcs =
            spec:isNpc() and distanceFromPlayer(spec:getPosition()) <= range and
                npcs + 1 or npcs;
    end
    return npcs;
end

-- main function for calculatin item amount in all visible containers
-- also considers equipped items
-- returns number
function itemAmount(id)
    return player:getItemsCount(id)
end

-- self explanatory
-- a is item to use on 
-- b is item to use a on
function useOnInvertoryItem(a, b)
    local item = findItem(b)
    if not item then return end

    return useWith(a, item)
end

-- pos can be tile or position
-- returns table of tiles surrounding given POS/tile
function getNearTiles(pos)
    if type(pos) ~= "table" then pos = pos:getPosition() end

    local tiles = {}
    local dirs = {
        {-1, 1}, {0, 1}, {1, 1}, {-1, 0}, {1, 0}, {-1, -1}, {0, -1}, {1, -1}
    }
    for i = 1, #dirs do
        local tile = g_map.getTile({
            x = pos.x - dirs[i][1],
            y = pos.y - dirs[i][2],
            z = pos.z
        })
        if tile then table.insert(tiles, tile) end
    end

    return tiles
end

-- self explanatory
-- use along with delay, it will only call action
function useGroundItem(id)
    if not id then return false end

    local dest = nil
    for i, tile in ipairs(g_map.getTiles(posz())) do
        for j, item in ipairs(tile:getItems()) do
            if item:getId() == id then
                dest = item
                break
            end
        end
    end

    if dest then
        return use(dest)
    else
        return false
    end
end

-- self explanatory
-- use along with delay, it will only call action
function reachGroundItem(id)
    if not id then return false end

    local dest = nil
    for i, tile in ipairs(g_map.getTiles(posz())) do
        for j, item in ipairs(tile:getItems()) do
            local iPos = item:getPosition()
            local iId = item:getId()
            if iId == id then
                if findPath(pos(), iPos, 20,
                            {ignoreNonPathable = true, precision = 1}) then
                    dest = item
                    break
                end
            end
        end
    end

    if dest then
        return autoWalk(iPos, 20, {ignoreNonPathable = true, precision = 1})
    else
        return false
    end
end

-- self explanatory
-- returns object
function findItemOnGround(id)
    for i, tile in ipairs(g_map.getTiles(posz())) do
        for j, item in ipairs(tile:getItems()) do
            if item:getId() == id then return item end
        end
    end
end

-- self explanatory
-- use along with delay, it will only call action
function useOnGroundItem(a, b)
    if not b then return false end
    local item = findItem(a)
    if not item then return false end

    local dest = nil
    for i, tile in ipairs(g_map.getTiles(posz())) do
        for j, item in ipairs(tile:getItems()) do
            if item:getId() == id then
                dest = item
                break
            end
        end
    end

    if dest then
        return useWith(item, dest)
    else
        return false
    end
end

-- returns target creature
function target()
    if not g_game.isAttacking() then
        return
    else
        return g_game.getAttackingCreature()
    end
end

-- returns target creature
function getTarget() return target() end

-- dist is boolean
-- returns target position/distance from player
function targetPos(dist)
    if not g_game.isAttacking() then return end
    if dist then
        return distanceFromPlayer(target():getPosition())
    else
        return target():getPosition()
    end
end

-- for gunzodus/ezodus only
-- it will reopen loot bag, necessary for depositer
function reopenPurse()
    for i, c in pairs(getContainers()) do
        if c:getName():lower() == "loot bag" or c:getName():lower() ==
            "store inbox" then g_game.close(c) end
    end
    schedule(100, function()
        g_game.use(g_game.getLocalPlayer():getInventoryItem(InventorySlotPurse))
    end)
    schedule(1400, function()
        for i, c in pairs(getContainers()) do
            if c:getName():lower() == "store inbox" then
                for _, i in pairs(c:getItems()) do
                    if i:getId() == 23721 then
                        g_game.open(i, c)
                    end
                end
            end
        end
    end)
    return CaveBot.delay(1500)
end

-- getSpectator patterns
-- param1 - pos/creature
-- param2 - pattern
-- param3 - type of return
-- 1 - everyone, 2 - monsters, 3 - players
-- returns number
function getCreaturesInArea(param1, param2, param3)
    local specs = 0
    local monsters = 0
    local players = 0
    for i, spec in pairs(getSpectators(param1, param2)) do
        if spec ~= player then
            specs = specs + 1
            if spec:isMonster() and
                (g_game.getClientVersion() < 960 or spec:getType() < 3) then
                monsters = monsters + 1
            elseif spec:isPlayer() and not isFriend(spec:getName()) then
                players = players + 1
            end
        end
    end

    if param3 == 1 then
        return specs
    elseif param3 == 2 then
        return monsters
    else
        return players
    end
end

-- can be improved
-- TODO in future
-- uses getCreaturesInArea, specType
-- returns number
function getBestTileByPatern(pattern, specType, maxDist, safe)
    if not pattern or not specType then return end
    if not maxDist then maxDist = 4 end

    local bestTile = nil
    local best = nil
    for _, tile in pairs(g_map.getTiles(posz())) do
        if distanceFromPlayer(tile:getPosition()) <= maxDist then
            local minimapColor = g_map.getMinimapColor(tile:getPosition())
            local stairs = (minimapColor >= 210 and minimapColor <= 213)
            if tile:canShoot() and tile:isWalkable() then
                if getCreaturesInArea(tile:getPosition(), pattern, specType) > 0 then
                    if (not safe or
                        getCreaturesInArea(tile:getPosition(), pattern, 3) == 0) then
                        local candidate =
                            {
                                pos = tile,
                                count = getCreaturesInArea(tile:getPosition(),
                                                           pattern, specType)
                            }
                        if not best or best.count <= candidate.count then
                            best = candidate
                        end
                    end
                end
            end
        end
    end

    bestTile = best

    if bestTile then
        return bestTile
    else
        return false
    end
end

-- returns container object based on name
function getContainerByName(name, notFull)
    if type(name) ~= "string" then return nil end

    local d = nil
    for i, c in pairs(getContainers()) do
        if c:getName():lower() == name:lower() and (not notFull or not containerIsFull(c)) then
            d = c
            break
        end
    end
    return d
end

-- returns container object based on container ID
function getContainerByItem(id, notFull)
    if type(id) ~= "number" then return nil end

    local d = nil
    for i, c in pairs(getContainers()) do
        if c:getContainerItem():getId() == id and (not notFull or not containerIsFull(c)) then
            d = c
            break
        end
    end
    return d
end

-- [[ ready to use getSpectators patterns ]] --
LargeUeArea = [[
    0000001000000
    0000011100000
    0000111110000
    0001111111000
    0011111111100
    0111111111110
    1111111111111
    0111111111110
    0011111111100
    0001111111000
    0000111110000
    0000011100000
    0000001000000
]]

NormalUeAreaMs = [[
    00000100000
    00011111000
    00111111100
    01111111110
    01111111110
    11111111111
    01111111110
    01111111110
    00111111100
    00001110000
    00000100000
]]

NormalUeAreaEd = [[
    00000100000
    00001110000
    00011111000
    00111111100
    01111111110
    11111111111
    01111111110
    00111111100
    00011111000
    00001110000
    00000100000
]]

smallUeArea = [[
    0011100
    0111110
    1111111
    1111111
    1111111
    0111110
    0011100
]]

largeRuneArea = [[
    0011100
    0111110
    1111111
    1111111
    1111111
    0111110
    0011100
]]

adjacentArea = [[
    111
    101
    111
]]

longBeamArea = [[
    0000000N0000000
    0000000N0000000
    0000000N0000000
    0000000N0000000
    0000000N0000000
    0000000N0000000
    0000000N0000000
    WWWWWWW0EEEEEEE
    0000000S0000000
    0000000S0000000
    0000000S0000000
    0000000S0000000
    0000000S0000000
    0000000S0000000
    0000000S0000000
]]

shortBeamArea = [[
    00000100000
    00000100000
    00000100000
    00000100000
    00000100000
    EEEEE0WWWWW
    00000S00000
    00000S00000
    00000S00000
    00000S00000
    00000S00000
]]

newWaveArea = [[
    000NNNNN000
    000NNNNN000
    0000NNN0000
    WW00NNN00EE
    WWWW0N0EEEE
    WWWWW0EEEEE
    WWWW0S0EEEE
    WW00SSS00EE
    0000SSS0000
    000SSSSS000
    000SSSSS000
]]

bigWaveArea = [[
    0000NNN0000
    0000NNN0000
    0000NNN0000
    00000N00000
    WWW00N00EEE
    WWWWW0EEEEE
    WWW00S00EEE
    00000S00000
    0000SSS0000
    0000SSS0000
    0000SSS0000
]]

smallWaveArea = [[
    00NNN00
    00NNN00
    WW0N0EE
    WWW0EEE
    WW0S0EE
    00SSS00
    00SSS00
]]

diamondArrowArea = [[
    01110
    11111
    11111
    11111
    01110
]]


-----------------------------------------------------------------

    HTTP.downloadImage("https://i.imgur.com/oFdI5iZ.png",
         function(image)
--button
scriptsButton = modules.client_topmenu.addRightGameToggleButton('scripts', 'Scripts [1]', image, toggle, false, 999999)
scriptsButton:setOn(false)

scriptsButton.onClick = function()
scriptsWindow:show()
end

scripts2Button = modules.game_buttons.buttonsWindow.contentsPanel and modules.game_buttons.buttonsWindow.contentsPanel.buttons.botscripts2Button
scripts2Button = scripts2Button or modules.client_topmenu.getButton("scripts2")
if scripts2Button then
    scripts2Button:destroy()
end

--button
scripts2Button = modules.client_topmenu.addRightGameToggleButton('scripts2', 'Scripts [2]', image, toggle, false, 999999)
scripts2Button:setOn(false)

scripts2Button.onClick = function()
scripts2Window:show()
end
end)

-- SCRIPTS 1 --

setDefaultTab("Main")
g_ui.loadUIFromString([[
scriptsScrollBar < Panel
  height: 28
  margin-top: 3


  UIWidget
    id: text
    anchors.left: parent.left
    anchors.right: parent.right
    anchors.top: parent.top
    text-align: center
    
  HorizontalScrollBar
    id: scroll
    anchors.left: parent.left
    anchors.right: parent.right
    anchors.top: prev.bottom
    margin-top: 3
    minimum: 0
    maximum: 10
    step: 1

scriptsTextEdit < Panel
  height: 40
  margin-top: 7

  UIWidget
    id: text
    anchors.left: parent.left
    anchors.right: parent.right
    anchors.top: parent.top
    text-align: center
    
  TextEdit
    id: textEdit
    anchors.left: parent.left
    anchors.right: parent.right
    anchors.top: prev.bottom
    margin-top: 5
    minimum: 0
    maximum: 10
    step: 1
    text-align: center


scriptsItem < Panel
  height: 34
  margin-top: 7
  margin-left: 25
  margin-right: 25


  UIWidget
    id: text
    anchors.left: parent.left
    anchors.verticalCenter: next.verticalCenter

  BotItem
    id: item
    anchors.top: parent.top
    anchors.right: parent.right



scriptsCheckBox < BotSwitch
  height: 20
  margin-top: 7

scriptsWindow < MainWindow
  !text: tr('Scripts')
  font: verdana-11px-rounded
  color: green
  size: 460 360
  padding: 25
  @onEscape: self:hide()



  Label
    anchors.left: parent.left
    anchors.right: parent.horizontalCenter
    anchors.top: parent.top
    text-align: center
    text: < PvP >
    font: verdana-11px-rounded
    color: pink

  Label
    anchors.left: parent.horizontalCenter
    anchors.right: parent.right
    anchors.top: parent.top
    text-align: center
    text: < Utilidades >
    font: verdana-11px-rounded
    color: pink



  VerticalScrollBar
    id: contentScroll
    anchors.top: prev.bottom
    margin-top: 3
    anchors.right: parent.right
    anchors.bottom: separator.top
    step: 28
    pixels-scroll: true
    margin-right: 190
    margin-top: 5
    margin-bottom: 5

  ScrollablePanel
    id: content
    anchors.top: prev.top
    anchors.left: parent.left
    anchors.right: parent.right
    anchors.bottom: separator.top
    vertical-scrollbar: contentScroll
    margin-bottom: 10

      
    Panel
      id: left
      anchors.top: parent.top
      anchors.left: parent.left
      anchors.right: parent.horizontalCenter
      margin-top: 5
      margin-left: 10
      margin-right: 10
      layout:
        type: verticalBox
        fit-children: true
    focusable: false


    Panel
      id: right
      anchors.top: parent.top
      anchors.left: parent.horizontalCenter
      anchors.right: parent.right
      margin-top: 5
      margin-left: 30
      margin-right: 13
      layout:
        type: verticalBox
        fit-children: true
      focusable: false




  HorizontalSeparator
    id: separator
    height: 16
    anchors.right: parent.right
    anchors.left: parent.left
    anchors.bottom: closeButton.top
    margin-bottom: 8

  ResizeBorder
    id: bottomResizeBorder
    anchors.fill: separator
    height: 3
    minimum: 260
    maximum: 600
    margin-left: 3
    margin-right: 3
    background: #ffffff88   

  Label
    id: stopp
    anchors.right: parent.right
    anchors.bottom: parent.bottom
    text-align: center
    margin-top: 16
    margin-right: 175
    font: verdana-11px-rounded
    text: @customized
    color: #00FFFF
    !tooltip: tr('Use fones de ouvido para ter uma experiencia melhor.')  

  Button
    id: closeButton
    !text: tr('Fechar')
    color: yellow
    font: verdana-11px-rounded
    anchors.right: parent.right
    anchors.bottom: parent.bottom
    size: 45 21
    margin-right: 5
]])




local panelName = "scripts"
local ui = setupUI([[
Panel

  height: 20

  ]], parent)
  ui:setId(PanelName)

if not storage[panelName] then
  storage[panelName] = {
}
end

local settings = storage[panelName]


scriptsWindow = UI.createWindow('scriptsWindow', rootWidget)
scriptsWindow:hide()

scriptsWindow.closeButton.onClick = function(widget)
  scriptsWindow:hide()
end


scriptsWindow.onGeometryChange = function(widget, old, new)
  if old.height == 0 then return end
  
  settings.height = new.height
end

scriptsWindow:setHeight(settings.height or 360)


local rightPanel = scriptsWindow.content.right
local leftPanel = scriptsWindow.content.left


modules.game_interface.addMenuHook("category", "Scripts",
  function()
          scriptsWindow:show()
  end,
  function(menuPosition, lookThing, useThing, creatureThing)
    if creatureThing and creatureThing == player then
      return true
    end
    return false
  end
)

local addCheckBox = function(id, title, defaultValue, dest, tooltip)
  local widget = UI.createWidget('scriptsCheckBox', dest)
  widget.onClick = function()
    widget:setOn(not widget:isOn())
    settings[id] = widget:isOn()
    if id == "checkPlayer" then
      local label = rootWidget.newHealer.targetSettings.vocations.title
      if not widget:isOn() then
        label:setColor("#d9321f")
        label:setTooltip("! WARNING ! \nTurn on check players in scripts to use this feature!")
      else
          label:setColor("#dfdfdf")
          label:setTooltip("")
      end
    end
  end
  widget:setText(title)
  widget:setTooltip(tooltip)
  if settings[id] == nil then
    widget:setOn(defaultValue)
  else
    widget:setOn(settings[id])
  end
  settings[id] = widget:isOn()
end

local addItem = function(id, title, defaultItem, dest, tooltip)
  local widget = UI.createWidget('scriptsItem', dest)
  widget.text:setText(title)
  widget.text:setColor("green")
  widget.text:setFont("verdana-11px-rounded")
  widget.text:setTooltip(tooltip)
  widget.item:setTooltip(tooltip)
  widget.item:setItemId(settings[id] or defaultItem)
  widget.item.onItemChange = function(widget)
    settings[id] = widget:getItemId()
  end
  settings[id] = settings[id] or defaultItem
end

local addTextEdit = function(id, title, defaultValue, dest, tooltip)
  local widget = UI.createWidget('scriptsTextEdit', dest)
  widget.text:setText(title)
  widget.text:setColor("green")
  widget.text:setFont("verdana-11px-rounded")
  widget.textEdit:setText(settings[id] or defaultValue or "")
  widget.text:setTooltip(tooltip)
  widget.textEdit.onTextChange = function(widget,text)
    settings[id] = text
  end
  settings[id] = settings[id] or defaultValue or ""
end

local addScrollBar = function(id, title, min, max, defaultValue, dest, tooltip)
  local widget = UI.createWidget('scriptsScrollBar', dest)
  widget.text:setTooltip(tooltip)
  widget.text:setColor("green")
  widget.text:setFont("verdana-11px-rounded")
  widget.scroll.onValueChange = function(scroll, value)
    widget.text:setText(title .. ": " .. value)
    if value == 0 then
      value = 1
    end
    settings[id] = value
  end
  widget.scroll:setRange(min, max)
  widget.scroll:setTooltip(tooltip)
  if max-min > 1000 then
    widget.scroll:setStep(100)
  elseif max-min > 100 then
    widget.scroll:setStep(10)
  end
  widget.scroll:setValue(settings[id] or defaultValue)
  widget.scroll.onValueChange(widget.scroll, widget.scroll:getValue())
end


local panelName = "killSteal"
local ui = setupUI([[
Panel
  height: 50
  
  BotItem
    id: item
    anchors.top: parent.top
    anchors.left: parent.left
    margin-top: 2
    
  BotSwitch
    id: title
    anchors.top: parent.top
    anchors.left: item.right
    anchors.bottom: item.verticalCenter
    text-align: center
    !text: tr('Kill Steal')
    margin-left: 2
    width: 90
  
  Button
    id: Target
    anchors.top: item.top
    anchors.left: title.right
    anchors.right: parent.right
    anchors.bottom: item.verticalCenter
    margin-left: 3
    text-align: center
    !text: tr('Switch')
  
  BotLabel
    id: help
    anchors.top: item.verticalCenter
    anchors.left: item.right
    anchors.right: parent.right
    anchors.bottom: item.bottom
    text-align: center
    margin-left: 2

  HorizontalScrollBar
    id: HP
    anchors.top: item.bottom
    anchors.left: parent.left
    anchors.right: parent.right
    margin-top: 3
    minimum: 1
    maximum: 100
    step: 1
    
]], leftPanel)
ui:setId(panelName)

if not storage[panelName] then
  storage[panelName] = {
      id = 3155,
      title = enabled,
      enabled = false,
      setting = true,
      hp = 20
  }
end

ui.title:setOn(storage[panelName].enabled)
ui.title.onClick = function(widget)
  storage[panelName].enabled = not storage[panelName].enabled
  widget:setOn(storage[panelName].enabled)
end
local updateHpText = function()
    local desc
    if storage[panelName].setting then
        desc = "Target"
    else
        desc = "Enemy"
    end
    ui.help:setText("If " .. desc .. " HP <= " .. storage[panelName].hp .. "%")
end
updateHpText()
ui.HP.onValueChange = function(scroll, value)
  storage[panelName].hp = value
  updateHpText()
end
ui.item:setItemId(storage[panelName].id)
ui.item.onItemChange = function(widget)
  storage[panelName].id = widget:getItemId()
end
ui.HP:setValue(storage[panelName].hp)

ui.Target.onClick = function(widget)
    storage[panelName].setting = not storage[panelName].setting
    updateHpText()
end

macro(1, function()
 if not storage[panelName].enabled then return end

 if storage[panelName].setting then
    if target() and target():canShoot() and target():getHealthPercent() <= storage[panelName].hp then
        useWith(storage[panelName].id, target())
    end
 else
    for _, spec in pairs(getSpectators()) do
        if spec:isPlayer() and spec:canShoot() and isEnemy(spec:getName()) and spec:getHealthPercent() <= storage[panelName].hp then
            useWith(storage[panelName].id, spec)
        end
    end
 end
end)

addSeparator()

UI.Label(" ", leftPanel):setWidth(50)
local panelName = "autoParty"
local autopartyui = setupUI([[
Panel
  height: 38

  BotSwitch
    id: status
    anchors.top: parent.top
    anchors.left: parent.left
    text-align: center
    width: 130
    height: 18
    text: Auto Party

  Button
    id: editPlayerList
    anchors.top: prev.top
    anchors.left: prev.right
    anchors.right: parent.right
    margin-left: 3
    height: 17
    text: Setup

  Button
    id: ptLeave
    text: Leave Party
    anchors.left: parent.left
    anchors.top: prev.bottom
    width: 86
    height: 17
    margin-top: 3
    color: #ee0000

  Button
    id: ptShare
    text: Share XP
    anchors.left: prev.right
    anchors.top: prev.top
    margin-left: 15
    height: 17
    width: 86

  ]], leftPanel)

g_ui.loadUIFromString([[
AutoPartyName < Label
  background-color: alpha
  text-offset: 2 0
  focusable: true
  height: 16

  $focus:
    background-color: #00000055

  Button
    id: remove
    text: x
    anchors.right: parent.right
    margin-right: 15
    width: 15
    height: 15

AutoPartyListWindow < MainWindow
  text: Auto Party
  size: 180 275
  @onEscape: self:hide()

  Label
    id: lblLeader
    anchors.left: parent.left
    anchors.right: parent.right
    anchors.top: parent.top
    anchors.right: parent.right
    text-align: center
    text: Leader Name

  TextEdit
    id: txtLeader
    anchors.left: parent.left
    anchors.right: parent.right
    anchors.top: prev.bottom
    margin-top: 5

  Label
    id: lblParty
    anchors.left: parent.left
    anchors.top: prev.bottom
    anchors.right: parent.right
    margin-top: 5
    text-align: center
    text: Party List

  TextList
    id: lstAutoParty
    anchors.top: prev.bottom
    anchors.left: parent.left
    anchors.right: parent.right
    margin-top: 5
    margin-bottom: 5
    padding: 1
    height: 83
    vertical-scrollbar: AutoPartyListListScrollBar

  VerticalScrollBar
    id: AutoPartyListListScrollBar
    anchors.top: lstAutoParty.top
    anchors.bottom: lstAutoParty.bottom
    anchors.right: lstAutoParty.right
    step: 14
    pixels-scroll: true

  TextEdit
    id: playerName
    anchors.left: parent.left
    anchors.top: lstAutoParty.bottom
    margin-top: 5
    width: 120

  Button
    id: addPlayer
    text: +
    anchors.right: parent.right
    anchors.left: prev.right
    anchors.top: prev.top
    margin-left: 3

  HorizontalSeparator
    id: separator
    anchors.right: parent.right
    anchors.left: parent.left
    anchors.top: prev.bottom
    margin-top: 8

  CheckBox
    id: creatureMove
    anchors.left: parent.left
    anchors.right: parent.right
    anchors.top: prev.bottom
    margin-top: 6
    text: Invite on move
    tooltip: This will activate the invite on player move.

  HorizontalSeparator
    id: separator
    anchors.right: parent.right
    anchors.left: parent.left
    anchors.bottom: closeButton.top
    margin-bottom: 8

  Button
    id: closeButton
    text: Close
    font: cipsoftFont
    anchors.right: parent.right
    anchors.bottom: parent.bottom
    size: 45 21
]], leftPanel)

if not storage[panelName] then
    storage[panelName] = {
        leaderName = 'Leader',
        autoPartyList = {},
        enabled = true,
    }
end

if not storage[panelName].onMove then
    storage[panelName].onMove = false
end
rootWidget = g_ui.getRootWidget()
if rootWidget then
    tcAutoParty = autopartyui.status

    autoPartyListWindow = UI.createWindow('AutoPartyListWindow', rootWidget)
    autoPartyListWindow:hide()

    autopartyui.editPlayerList.onClick = function(widget)
        autoPartyListWindow:show()
        autoPartyListWindow:raise()
        autoPartyListWindow:focus()
    end

    autopartyui.ptShare.onClick = function(widget)
        g_game.partyShareExperience(not player:isPartySharedExperienceActive())
    end

    autopartyui.ptLeave.onClick = function(widget)
        g_game.partyLeave()
    end

    autoPartyListWindow.closeButton.onClick = function(widget)
        autoPartyListWindow:hide()
    end

    if storage[panelName].autoPartyList and #storage[panelName].autoPartyList > 0 then
        for _, pName in ipairs(storage[panelName].autoPartyList) do
            local label = g_ui.createWidget("AutoPartyName", autoPartyListWindow.lstAutoParty)
            label.remove.onClick = function(widget)
                table.removevalue(storage[panelName].autoPartyList, label:getText())
                label:destroy()
            end
            label:setText(pName)
        end
    end
    autoPartyListWindow.addPlayer.onClick = function(widget)
        local playerName = autoPartyListWindow.playerName:getText()
        if playerName:len() > 0 and not (table.contains(storage[panelName].autoPartyList, playerName, true)
                or storage[panelName].leaderName == playerName) then
            table.insert(storage[panelName].autoPartyList, playerName)
            local label = g_ui.createWidget("AutoPartyName", autoPartyListWindow.lstAutoParty)
            label.remove.onClick = function(widget)
                table.removevalue(storage[panelName].autoPartyList, label:getText())
                label:destroy()
            end
            label:setText(playerName)
            autoPartyListWindow.playerName:setText('')
        end
    end

    autopartyui.status:setOn(storage[panelName].enabled)
    autopartyui.status.onClick = function(widget)
        storage[panelName].enabled = not storage[panelName].enabled
        widget:setOn(storage[panelName].enabled)
    end

    autoPartyListWindow.creatureMove:setChecked(storage[panelName].onMove)
    autoPartyListWindow.creatureMove.onClick = function(widget)
        storage[panelName].onMove = not storage[panelName].onMove
        widget:setChecked(storage[panelName].onMove)
    end

    autoPartyListWindow.playerName.onKeyPress = function(self, keyCode, keyboardModifiers)
        if not (keyCode == 5) then
            return false
        end
        autoPartyListWindow.addPlayer.onClick()
        return true
    end

    autoPartyListWindow.playerName.onTextChange = function(widget, text)
        if table.contains(storage[panelName].autoPartyList, text, true) then
            autoPartyListWindow.addPlayer:setColor("#FF0000")
        else
            autoPartyListWindow.addPlayer:setColor("#FFFFFF")
        end
    end

    autoPartyListWindow.txtLeader.onTextChange = function(widget, text)
        storage[panelName].leaderName = text
    end
    autoPartyListWindow.txtLeader:setText(storage[panelName].leaderName)

    onTextMessage(function(mode, text)
        if tcAutoParty:isOn() then
            if mode == 20 then
                if text:find("has joined the party") then
                    local data = regexMatch(text, "([a-z A-Z-]*) has joined the party")[1][2]
                    if data then
                        if table.contains(storage[panelName].autoPartyList, data, true) then
                            if not player:isPartySharedExperienceActive() then
                                g_game.partyShareExperience(true)
                            end
                        end
                    end
                elseif text:find("has invited you") then
                    if player:getName():lower() == storage[panelName].leaderName:lower() then
                        return
                    end
                    local data = regexMatch(text, "([a-z A-Z-]*) has invited you")[1][2]
                    if data then
                        if storage[panelName].leaderName:lower() == data:lower() then
                            local leader = getCreatureByName(data, true)
                            if leader then
                                g_game.partyJoin(leader:getId())
                                return
                            end
                        end
                    end
                end
            end
        end
    end)

    function creatureInvites(creature)
        if not creature:isPlayer() or creature == player then return end
        if creature:getName():lower() == storage[panelName].leaderName:lower() then
            if creature:getShield() == 1 then
                g_game.partyJoin(creature:getId())
                return
            end
        end
        if player:getName():lower() ~= storage[panelName].leaderName:lower() then return end
        if not table.contains(storage[panelName].autoPartyList, creature:getName(), true) then return end
        if creature:isPartyMember() or creature:getShield() == 2 then return end
        g_game.partyInvite(creature:getId())
    end

    onCreatureAppear(function(creature)
        if tcAutoParty:isOn() then
            creatureInvites(creature)
        end
    end)
    onCreaturePositionChange(function(creature, newPos, oldPos)
        if tcAutoParty:isOn() and storage[panelName].onMove then
            creatureInvites(creature)
        end
    end)
end

g_ui.loadUIFromString([[
outfitidWindow < MainWindow
  !text: tr('OutfitHack Settings')
  size: 200 160
  @onEscape: self:hide()

  BotLabel
    id: OutfitID
    anchors.top: parent.top
    anchors.left: parent.left
    anchors.right: parent.right
    text-align: center


  Label
    id: label1
    anchors.top: parent.top
    anchors.left: parent.left
    anchors.right: parent.right
    text-align: center
    text: ID da Outfit:
    color: teal

  TextEdit
    id: IDAQUI
    anchors.left: parent.left
    anchors.right: parent.right
    anchors.top: label1.bottom
    margin-top: 5
    text-align: center

  BotSwitch
    id: findOutfit
    anchors.left: parent.left
    anchors.right: parent.right
    anchors.top: IDAQUI.bottom
    text-align: center
    text: FIND OUTFIT

  HorizontalSeparator
    id: separator
    anchors.right: parent.right
    anchors.left: parent.left
    anchors.top: findOutfit.bottom
    margin-bottom: 8 

  Label
    id: label2
    anchors.top: separator.bottom
    anchors.left: parent.left
    anchors.right: parent.right
    text-align: center
    text: start to count!
    color: teal

  Button
    id: closeButton
    !text: tr('Close')
    font: cipsoftFont
    anchors.right: parent.right
    anchors.bottom: parent.bottom
    size: 45 21
    margin-top: 15
    margin-right: 5    

  Button
    id: resetButton
    !text: tr('Reset')
    font: cipsoftFont
    anchors.left: parent.left
    anchors.top: parent.bottom
    size: 45 21
    margin-top: -20
    margin-right: 5   

]])


local panelName = "outfit"
local ui = setupUI([[
Panel
  height: 17

  BotSwitch
    id: titleoutfit
    anchors.top: parent.top
    anchors.left: parent.left
    text-align: center
    width: 115
    !text: tr('OUTFIT HACK')
    font: terminus-14px-bold

  Button
    id: outfitid
    anchors.top: prev.top
    anchors.left: prev.right
    anchors.right: parent.right
    margin-left: 6
    height: 17
    text: SETUP
    font: verdana-11px-rounded

  ]], leftPanel)
  ui:setId(panelName)

  if not storage[panelName] then
  storage[panelName] = {
    enabled = false,
    outfitid = "0",
    outfithack = false,
    findOutfit = false
  }
  end

  local config = storage[panelName]

  ui.titleoutfit:setOn(config.enabled)
  ui.titleoutfit.onClick = function(widget)
  config.enabled = not config.enabled
  widget:setOn(config.enabled)
  end

  ui.outfitid.onClick = function(widget)
    outfitidWindow:show()
    outfitidWindow:raise()
    outfitidWindow:focus()
  end

  rootWidget = g_ui.getRootWidget()
    if rootWidget then

      outfitidWindow = UI.createWindow('outfitidWindow', rootWidget)
      outfitidWindow:hide()

      outfitidWindow.closeButton.onClick = function(widget)
      outfitidWindow:hide()
    end
      outfitidWindow.IDAQUI.onTextChange = function(widget, text)
      config.outfitid = text
    end
   outfitidWindow.IDAQUI:setText(config.outfitid)
 end
       outfitidWindow.findOutfit:setOn(config.findOutfit)
      outfitidWindow.findOutfit.onClick = function(widget)
      config.findOutfit = not config.findOutfit
      widget:setOn(config.findOutfit)
        end

macro(1, function()
if config.enabled then
  if not config.findOutfit then
    if player:getOutfit().type ~= tonumber(config.outfitid) then
      player:setOutfit({type = tonumber(config.outfitid)})
    end
end
end
end)

local tiype = 0
macro(100,function()
  if config.findOutfit then
    tiype = tiype +1
    player:setOutfit({type = tiype})
    outfitidWindow.label2:setText(tiype)
    outfitidWindow.label2:setColor("pink")
end
end)

outfitidWindow.resetButton.onClick = function(widget)
  tiype = 0
  outfitidWindow.label2:setText("start to count!")
  outfitidWindow.label2:setColor("teal")
  player:setOutfit({type = tonumber(config.outfitid)})
end


-- X-RAY Script

addCheckBox("xray", "X-RAY", false, leftPanel, "veja as pessoas abaixo.")
if true then end
macro(1, function()
  if xray then
    for _, spec in ipairs(getSpectators(true)) do
        if spec:isPlayer() or spec:isNpc() or spec:isMonster() then
            if spec:getPosition().z > posz() then
                local tile = g_map.getTile({x = spec:getPosition().x, y = spec:getPosition().y, z = posz()})
                if tile then
                    tile:setText(spec:getName(), "#787878")
                end
            end
        end
    end
  end
end)
onCreaturePositionChange(function(creature, newPos, oldPos)
  if creature == player then return end
  if type(oldPos) ~= "table" then return end  
      oldPos = {x = oldPos.x, y = oldPos.y, z = posz()}
      local tile = g_map.getTile(oldPos)
      if (tile) then
          tile:setText()
      end
end)


-- Configs

local configName = modules.game_bot.contentsPanel.config:getCurrentOption().text

-- make vBot config dir
if not g_resources.directoryExists("/bot/".. configName .."/vBot_configs/") then
  g_resources.makeDir("/bot/".. configName .."/vBot_configs/")
end

-- make profile dirs
for i=1,10 do
  local path = "/bot/".. configName .."/vBot_configs/profile_"..i
  if not g_resources.directoryExists(path) then
    g_resources.makeDir(path)
  end
end

local profile = "1"

HealBotConfig = {}
local healBotFile = "/bot/" .. configName .. "/vBot_configs/profile_".. profile .. "/HealBot.json"
AttackBotConfig = {}
local attackBotFile = "/bot/" .. configName .. "/vBot_configs/profile_".. profile .. "/AttackBot.json"
SuppliesConfig = {}
local suppliesFile = "/bot/" .. configName .. "/vBot_configs/profile_".. profile .. "/Supplies.json"


--healbot
if g_resources.fileExists(healBotFile) then
    local status, result = pcall(function() 
      return json.decode(g_resources.readFileContents(healBotFile)) 
    end)
    if not status then
      return onError("Error while reading config file (" .. healBotFile .. "). To fix this problem you can delete HealBot.json. Details: " .. result)
    end
    HealBotConfig = result
end

--attackbot
if g_resources.fileExists(attackBotFile) then
    local status, result = pcall(function() 
      return json.decode(g_resources.readFileContents(attackBotFile)) 
    end)
    if not status then
      return onError("Error while reading config file (" .. attackBotFile .. "). To fix this problem you can delete HealBot.json. Details: " .. result)
    end
    AttackBotConfig = result
end

--supplies
if g_resources.fileExists(suppliesFile) then
    local status, result = pcall(function() 
      return json.decode(g_resources.readFileContents(suppliesFile)) 
    end)
    if not status then
      return onError("Error while reading config file (" .. suppliesFile .. "). To fix this problem you can delete HealBot.json. Details: " .. result)
    end
    SuppliesConfig = result
end

function vBotConfigSave(file)
  -- file can be either
  --- heal
  --- atk
  --- supply
  local configFile 
  local configTable
  if not file then return end
  file = file:lower()
  if file == "heal" then
      configFile = healBotFile
      configTable = HealBotConfig
  elseif file == "atk" then
      configFile = attackBotFile
      configTable = AttackBotConfig
  elseif file == "supply" then
      configFile = suppliesFile
      configTable = SuppliesConfig
  else
    return
  end

  local status, result = pcall(function() 
    return json.encode(configTable, 2) 
  end)
  if not status then
    return onError("Error while saving config. it won't be saved. Details: " .. result)
  end
  
  if result:len() > 100 * 1024 * 1024 then
    return onError("config file is too big, above 100MB, it won't be saved")
  end

  g_resources.writeFileContents(configFile, result)
end

-- FIM

-- LifeBot

g_ui.loadUIFromString([[
SettingCheckBox < CheckBox
  text-wrap: true
  text-auto-resize: true
  margin-top: 3
  font: verdana-11px-rounded

SpellSourceBoxPopupMenu < ComboBoxPopupMenu
SpellSourceBoxPopupMenuButton < ComboBoxPopupMenuButton
SpellSourceBox < ComboBox
  @onSetup: |
    self:addOption("Current Mana")
    self:addOption("Current Health")
    self:addOption("Mana Percent")
    self:addOption("Health Percent")
    self:addOption("Burst Damage")

SpellConditionBoxPopupMenu < ComboBoxPopupMenu
SpellConditionBoxPopupMenuButton < ComboBoxPopupMenuButton
SpellConditionBox < ComboBox
  @onSetup: |
    self:addOption("Below")
    self:addOption("Above")
    self:addOption("Equal To")

SpellEntry < Label
  background-color: alpha
  text-offset: 18 1
  focusable: true
  height: 16
  font: verdana-11px-rounded

  CheckBox
    id: enabled
    anchors.left: parent.left
    anchors.verticalCenter: parent.verticalCenter
    width: 15
    height: 15
    margin-top: 2
    margin-left: 3

  $focus:
    background-color: #00000055

  Button
    id: remove
    !text: tr('x')
    anchors.right: parent.right
    margin-right: 15
    text-offset: 1 0
    width: 15
    height: 15   

ItemEntry < Label
  background-color: alpha
  text-offset: 40 1
  focusable: true
  height: 16
  font: verdana-11px-rounded

  CheckBox
    id: enabled
    anchors.left: parent.left
    anchors.verticalCenter: parent.verticalCenter
    width: 15
    height: 15
    margin-top: 2
    margin-left: 3

  UIItem
    id: id
    anchors.left: prev.right
    margin-left: 3
    anchors.verticalCenter: parent.verticalCenter
    size: 15 15
    focusable: false

  $focus:
    background-color: #00000055

  Button
    id: remove
    !text: tr('x')
    anchors.right: parent.right
    margin-right: 15
    text-offset: 1 0
    width: 15
    height: 15               

SpellHealing < FlatPanel
  size: 490 130

  Label
    id: title
    anchors.verticalCenter: parent.top
    anchors.left: parent.left
    margin-left: 5
    text: Spell Healing
    color: #269e26
    font: verdana-11px-rounded

  SpellSourceBox
    id: spellSource
    anchors.top: spellList.top
    anchors.left: spellList.right
    margin-left: 80
    width: 125
    font: verdana-11px-rounded

  Label
    id: whenSpell
    anchors.left: spellList.right
    anchors.verticalCenter: prev.verticalCenter
    text: When
    margin-left: 7
    font: verdana-11px-rounded

  Label
    id: isSpell
    anchors.left: spellList.right
    anchors.top: whenSpell.bottom
    text: Is
    margin-top: 9
    margin-left: 7 
    font: verdana-11px-rounded

  SpellConditionBox
    id: spellCondition
    anchors.left: spellSource.left
    anchors.top: spellSource.bottom   
    marin-top: 15
    width: 80
    font: verdana-11px-rounded

  TextEdit
    id: spellValue
    anchors.left: spellCondition.right
    anchors.top: spellCondition.top
    anchors.bottom: spellCondition.bottom
    anchors.right: spellSource.right
    font: verdana-11px-rounded

  Label
    id: castSpell
    anchors.left: isSpell.left
    anchors.top: isSpell.bottom
    text: Cast  
    margin-top: 9
    font: verdana-11px-rounded

  TextEdit
    id: spellFormula
    anchors.left: spellCondition.left
    anchors.top: spellCondition.bottom
    anchors.right: spellValue.right
    font: verdana-11px-rounded

  Label
    id: manaSpell
    anchors.left: castSpell.left
    anchors.top: castSpell.bottom
    text: Cooldown:
    margin-top: 8
    font: verdana-11px-rounded

  TextEdit
    id: manaCost
    anchors.left: spellFormula.left
    anchors.top: spellFormula.bottom
    width: 40 
    font: verdana-11px-rounded

  TextList
    id: spellList
    anchors.left: parent.left
    anchors.bottom: parent.bottom
    anchors.top: parent.top
    padding: 1
    padding-top: 2
    width: 270  
    margin-bottom: 7
    margin-left: 7
    margin-top: 10
    vertical-scrollbar: spellListScrollBar

  VerticalScrollBar
    id: spellListScrollBar
    anchors.top: spellList.top
    anchors.bottom: spellList.bottom
    anchors.right: spellList.right
    step: 14
    pixels-scroll: true

  Button
    id: addSpell
    anchors.right: spellFormula.right
    anchors.bottom: spellList.bottom
    text: Add
    size: 40 17
    font: cipsoftFont

  Button
    id: MoveUp
    anchors.right: prev.left
    anchors.bottom: prev.bottom
    margin-right: 5
    text: Move Up
    size: 55 17
    font: cipsoftFont

  Button
    id: MoveDown
    anchors.right: prev.left
    anchors.bottom: prev.bottom
    margin-right: 5
    text: Move Down
    size: 55 17
    font: cipsoftFont  

ItemHealing < FlatPanel
  size: 490 120

  Label
    id: title
    anchors.verticalCenter: parent.top
    anchors.left: parent.left
    margin-left: 5
    text: Item Healing
    color: #ff4513
    font: verdana-11px-rounded

  SpellSourceBox
    id: itemSource
    anchors.top: itemList.top
    anchors.right: parent.right
    margin-right: 10
    width: 128
    font: verdana-11px-rounded

  Label
    id: whenItem
    anchors.left: itemList.right
    anchors.verticalCenter: prev.verticalCenter
    text: When
    margin-left: 7
    font: verdana-11px-rounded

  Label
    id: isItem
    anchors.left: itemList.right
    anchors.top: whenItem.bottom
    text: Is
    margin-top: 9
    margin-left: 7 
    font: verdana-11px-rounded

  SpellConditionBox
    id: itemCondition
    anchors.left: itemSource.left
    anchors.top: itemSource.bottom   
    marin-top: 15
    width: 80
    font: verdana-11px-rounded

  TextEdit
    id: itemValue
    anchors.left: itemCondition.right
    anchors.top: itemCondition.top
    anchors.bottom: itemCondition.bottom
    width: 49
    font: verdana-11px-rounded

  Label
    id: useItem
    anchors.left: isItem.left
    anchors.top: isItem.bottom
    text: Use  
    margin-top: 15
    font: verdana-11px-rounded

  BotItem
    id: itemId
    anchors.left: itemCondition.left
    anchors.top: itemCondition.bottom

  TextList
    id: itemList
    anchors.left: parent.left
    anchors.bottom: parent.bottom
    anchors.top: parent.top
    padding: 1
    padding-top: 2
    width: 270  
    margin-top: 10
    margin-bottom: 7
    margin-left: 8
    vertical-scrollbar: itemListScrollBar

  VerticalScrollBar
    id: itemListScrollBar
    anchors.top: itemList.top
    anchors.bottom: itemList.bottom
    anchors.right: itemList.right
    step: 14
    pixels-scroll: true

  Button
    id: addItem
    anchors.right: itemValue.right
    anchors.bottom: itemList.bottom
    text: Add
    size: 40 17
    font: cipsoftFont

  Button
    id: MoveUp
    anchors.right: prev.left
    anchors.bottom: prev.bottom
    margin-right: 5
    text: Move Up
    size: 55 17
    font: cipsoftFont

  Button
    id: MoveDown
    anchors.right: prev.left
    anchors.bottom: prev.bottom
    margin-right: 5
    text: Move Down
    size: 55 17
    font: cipsoftFont

HealerPanel < Panel
  size: 510 275

  SpellHealing
    id: spells
    anchors.top: parent.top
    margin-top: 8
    anchors.left: parent.left

  ItemHealing
    id: items
    anchors.top: prev.bottom
    anchors.left: parent.left
    margin-top: 10

HealBotSettingsPanel < Panel
  size: 500 267
  padding-top: 8

  FlatPanel
    id: list
    anchors.fill: parent
    margin-right: 240
    padding-left: 6
    padding-right: 6
    padding-top: 6
    layout:
      type: verticalBox

    Label
      text: Additional Settings
      text-align: center
      font: verdana-11px-rounded
      
    HorizontalSeparator

    SettingCheckBox
      id: Cooldown
      text: Check spell cooldowns
      margin-top: 10

    SettingCheckBox
      id: Visible
      text: Items must be visible (recommended)

    SettingCheckBox
      id: Delay
      text: Don't use items when interacting

    SettingCheckBox
      id: Interval
      text: Additional delay when looting corpses

    SettingCheckBox
      id: Conditions
      text: Also check conditions from RL Tibia

    SettingCheckBox
      id: MessageDelay
      text: Cooldown based on "Aaaah..." message

  VerticalSeparator
    anchors.top: prev.top
    anchors.bottom: prev.bottom
    anchors.left: prev.right
    margin-left: 8

  FlatPanel
    id: profiles
    anchors.fill: parent
    anchors.left: prev.left
    margin-left: 8
    margin-right: 8
    padding: 8

    Label
      text: Profile Settings
      text-align: center
      anchors.top: parent.top
      anchors.left: parent.left
      anchors.right: parent.right
      font: verdana-11px-rounded

    HorizontalSeparator
      anchors.top: prev.bottom
      anchors.left: parent.left
      anchors.right: parent.right

    Label
      anchors.top: prev.bottom
      margin-top: 30
      anchors.left: parent.left
      anchors.right: parent.right
      text-align: center
      font: verdana-11px-rounded
      text: Profile Name:

    TextEdit
      id: Name
      anchors.top: prev.bottom
      margin-top: 3
      anchors.left: parent.left
      anchors.right: parent.right     

    Button
      id: ResetSettings
      anchors.bottom: parent.bottom
      anchors.horizontalCenter: parent.horizontalCenter
      text: Reset Current Profile
      text-auto-resize: true
      color: #ff4513

HealWindow < MainWindow
  !text: tr('Self Healer')
  size: 520 360
  @onEscape: self:hide()
  color: darkTeal

  Label
    id: title
    anchors.left: parent.left
    anchors.top: parent.top
    margin-left: 2
    !text: tr('                       Adicione aqui tudo que usa baseado na sua vida ou mana.')
    text-align: left
    font: verdana-11px-rounded
    color: #aeaeae  

  HealerPanel
    id: healer
    anchors.top: prev.bottom
    anchors.left: parent.left

  HealBotSettingsPanel
    id: settings
    anchors.top: title.bottom
    anchors.left: parent.left
    visible: false

  HorizontalSeparator
    id: separator
    anchors.right: parent.right
    anchors.left: parent.left
    anchors.bottom: closeButton.top
    margin-bottom: 8    

  Button
    id: closeButton
    !text: tr('Close')
    font: cipsoftFont
    anchors.right: parent.right
    anchors.bottom: parent.bottom
    size: 45 21
    margin-right: 5
    color: red

  Button
    id: settingsButton
    !text: tr('Settings')
    font: cipsoftFont
    anchors.left: parent.left
    anchors.bottom: parent.bottom
    size: 45 21
    color: blue
]])

local standBySpells = false
local standByItems = false

local red = "#ff0800" -- "#ff0800" / #ea3c53 best
local blue = "#7ef9ff"

local healPanelName = "healbot"
local ui = setupUI([[
Panel
  height: 28


  Label 
    id: labelz
    text: ~HEALING:
    anchors.top: parent.top 
    anchors.left: parent.left
    margin-left: 50
    font: cipsoftFont
    color: #E0FFFF

  BotSwitch
    id: title
    anchors.top: labelz.bottom
    anchors.left: parent.left
    text-align: center
    width: 115
    color: yellow
    height: 17
    font: terminus-14px-bold

  Button
    id: settings
    anchors.top: prev.top
    anchors.left: prev.right
    anchors.right: parent.right
    margin-left: 6
    height: 17
    text: SETUP
    font: verdana-11px-rounded

]], rightPanel)
ui:setId(healPanelName)

if not HealBotConfig[healPanelName] or not HealBotConfig[healPanelName][1] or #HealBotConfig[healPanelName] ~= 5 then
  HealBotConfig[healPanelName] = {
    [1] = {
      enabled = false,
      spellTable = {},
      itemTable = {},
      name = "Profile #1",
      Visible = true,
      Cooldown = true,
      Interval = true,
      Conditions = true,
      Delay = true,
      MessageDelay = false
    },
    [2] = {
      enabled = false,
      spellTable = {},
      itemTable = {},
      name = "Profile #2",
      Visible = true,
      Cooldown = true,
      Interval = true,
      Conditions = true,
      Delay = true,
      MessageDelay = false
    },
    [3] = {
      enabled = false,
      spellTable = {},
      itemTable = {},
      name = "Profile #3",
      Visible = true,
      Cooldown = true,
      Interval = true,
      Conditions = true,
      Delay = true,
      MessageDelay = false
    },
    [4] = {
      enabled = false,
      spellTable = {},
      itemTable = {},
      name = "Profile #4",
      Visible = true,
      Cooldown = true,
      Interval = true,
      Conditions = true,
      Delay = true,
      MessageDelay = false
    },
    [5] = {
      enabled = false,
      spellTable = {},
      itemTable = {},
      name = "Profile #5",
      Visible = true,
      Cooldown = true,
      Interval = true,
      Conditions = true,
      Delay = true,
      MessageDelay = false
    },
  }
end

if not HealBotConfig.currentHealBotProfile or HealBotConfig.currentHealBotProfile == 0 or HealBotConfig.currentHealBotProfile > 5 then 
  HealBotConfig.currentHealBotProfile = 1
end

-- finding correct table, manual unfortunately
local currentSettings
local setActiveProfile = function()
  local n = HealBotConfig.currentHealBotProfile
  currentSettings = HealBotConfig[healPanelName][n]
end
setActiveProfile()


ui.title:setOn(currentSettings.enabled)
ui.title.onClick = function(widget)
  currentSettings.enabled = not currentSettings.enabled
  widget:setOn(currentSettings.enabled)
  vBotConfigSave("heal")
end

macro(1, function()
  if currentSettings.enabled then 
    ui.title:setText("ENABLED")
  else
    ui.title:setText("DISABLED")
  end
end)

ui.settings.onClick = function(widget)
  healWindow:show()
  healWindow:raise()
  healWindow:focus()
end

rootWidget = g_ui.getRootWidget()
if rootWidget then
  healWindow = UI.createWindow('HealWindow', rootWidget)
  healWindow:hide()

  healWindow.onVisibilityChange = function(widget, visible)
    if not visible then
      vBotConfigSave("heal")
      healWindow.healer:show()
      healWindow.settings:hide()
      healWindow.settingsButton:setText("Settings")
    end
  end

  healWindow.settingsButton.onClick = function(widget)
    if healWindow.healer:isVisible() then
      healWindow.healer:hide()
      healWindow.settings:show()
      widget:setText("Back")
    else
      healWindow.healer:show()
      healWindow.settings:hide()
      widget:setText("Settings")
    end
  end

  healWindow.settings.list.Visible.onClick = function(widget)
    currentSettings.Visible = not currentSettings.Visible
    healWindow.settings.list.Visible:setChecked(currentSettings.Visible)
  end
  healWindow.settings.list.Cooldown.onClick = function(widget)
    currentSettings.Cooldown = not currentSettings.Cooldown
    healWindow.settings.list.Cooldown:setChecked(currentSettings.Cooldown)
  end
  healWindow.settings.list.Interval.onClick = function(widget)
    currentSettings.Interval = not currentSettings.Interval
    healWindow.settings.list.Interval:setChecked(currentSettings.Interval)
  end
  healWindow.settings.list.Conditions.onClick = function(widget)
    currentSettings.Conditions = not currentSettings.Conditions
    healWindow.settings.list.Conditions:setChecked(currentSettings.Conditions)
  end
  healWindow.settings.list.Delay.onClick = function(widget)
    currentSettings.Delay = not currentSettings.Delay
    healWindow.settings.list.Delay:setChecked(currentSettings.Delay)
  end
  healWindow.settings.list.MessageDelay.onClick = function(widget)
    currentSettings.MessageDelay = not currentSettings.MessageDelay
    healWindow.settings.list.MessageDelay:setChecked(currentSettings.MessageDelay)
  end

  local refreshSpells = function()
    if currentSettings.spellTable then
      healWindow.healer.spells.spellList:destroyChildren()
      for _, entry in pairs(currentSettings.spellTable) do
        if not entry.totalcd then 
          entry.totalcd = 0 
        end
        local label = UI.createWidget("SpellEntry", healWindow.healer.spells.spellList)
        label.enabled:setChecked(entry.enabled)
        label.enabled.onClick = function(widget)
          standBySpells = false
          standByItems = false
          entry.enabled = not entry.enabled
          label.enabled:setChecked(entry.enabled)
        end
        label.remove.onClick = function(widget)
          standBySpells = false
          standByItems = false
          table.removevalue(currentSettings.spellTable, entry)
          reindexTable(currentSettings.spellTable)
          label:destroy()
        end
        label:setColoredText({"[", "white", entry.value.."%", "red","] ", "white", entry.spell, "teal", " [", "white", (entry.cost/1000).. "s", "orange", "]", "white"})
      end
    end
  end
  refreshSpells()

  local refreshItems = function()
    if currentSettings.itemTable then
      healWindow.healer.items.itemList:destroyChildren()
      for _, entry in pairs(currentSettings.itemTable) do
        local label = UI.createWidget("ItemEntry", healWindow.healer.items.itemList)
        label.enabled:setChecked(entry.enabled)
        label.enabled.onClick = function(widget)
          standBySpells = false
          standByItems = false
          entry.enabled = not entry.enabled
          label.enabled:setChecked(entry.enabled)
        end
        label.remove.onClick = function(widget)
          standBySpells = false
          standByItems = false
          table.removevalue(currentSettings.itemTable, entry)
          reindexTable(currentSettings.itemTable)
          label:destroy()
        end
        label.id:setItemId(entry.item)
        label:setText(entry.origin.. " ".. entry.sign.. " ".. entry.value.. "%".. " ID: " .. entry.item)
        label:setColor("darkGreen")
      end
    end
  end
  refreshItems()

  healWindow.healer.spells.MoveUp.onClick = function(widget)
    local input = healWindow.healer.spells.spellList:getFocusedChild()
    if not input then return end
    local index = healWindow.healer.spells.spellList:getChildIndex(input)
    if index < 2 then return end

    local t = currentSettings.spellTable

    t[index],t[index-1] = t[index-1], t[index]
    healWindow.healer.spells.spellList:moveChildToIndex(input, index - 1)
    healWindow.healer.spells.spellList:ensureChildVisible(input)
  end

  healWindow.healer.spells.MoveDown.onClick = function(widget)
    local input = healWindow.healer.spells.spellList:getFocusedChild()
    if not input then return end
    local index = healWindow.healer.spells.spellList:getChildIndex(input)
    if index >= healWindow.healer.spells.spellList:getChildCount() then return end

    local t = currentSettings.spellTable

    t[index],t[index+1] = t[index+1],t[index]
    healWindow.healer.spells.spellList:moveChildToIndex(input, index + 1)
    healWindow.healer.spells.spellList:ensureChildVisible(input)
  end

  healWindow.healer.items.MoveUp.onClick = function(widget)
    local input = healWindow.healer.items.itemList:getFocusedChild()
    if not input then return end
    local index = healWindow.healer.items.itemList:getChildIndex(input)
    if index < 2 then return end

    local t = currentSettings.itemTable

    t[index],t[index-1] = t[index-1], t[index]
    healWindow.healer.items.itemList:moveChildToIndex(input, index - 1)
    healWindow.healer.items.itemList:ensureChildVisible(input)
  end

  healWindow.healer.items.MoveDown.onClick = function(widget)
    local input = healWindow.healer.items.itemList:getFocusedChild()
    if not input then return end
    local index = healWindow.healer.items.itemList:getChildIndex(input)
    if index >= healWindow.healer.items.itemList:getChildCount() then return end

    local t = currentSettings.itemTable

    t[index],t[index+1] = t[index+1],t[index]
    healWindow.healer.items.itemList:moveChildToIndex(input, index + 1)
    healWindow.healer.items.itemList:ensureChildVisible(input)
  end

  healWindow.healer.spells.addSpell.onClick = function(widget)
 
    local spellFormula = healWindow.healer.spells.spellFormula:getText():trim()
    local manaCost = tonumber(healWindow.healer.spells.manaCost:getText())
    local spellTrigger = tonumber(healWindow.healer.spells.spellValue:getText())
    local spellSource = healWindow.healer.spells.spellSource:getCurrentOption().text
    local spellEquasion = healWindow.healer.spells.spellCondition:getCurrentOption().text
    local source
    local equasion

    if not manaCost then  
      warn("HealBot: incorrect mana cost value!")       
      healWindow.healer.spells.spellFormula:setText('')
      healWindow.healer.spells.spellValue:setText('')
      healWindow.healer.spells.manaCost:setText('') 
      return 
    end
    if not spellTrigger then  
      warn("HealBot: incorrect condition value!") 
      healWindow.healer.spells.spellFormula:setText('')
      healWindow.healer.spells.spellValue:setText('')
      healWindow.healer.spells.manaCost:setText('')
      return 
    end

    if spellSource == "Current Mana" then
      source = "MP"
    elseif spellSource == "Current Health" then
      source = "HP"
    elseif spellSource == "Mana Percent" then
      source = "MP%"
    elseif spellSource == "Health Percent" then
      source = "HP%"
    else
      source = "burst"
    end
    
    if spellEquasion == "Above" then
      equasion = ">"
    elseif spellEquasion == "Below" then
      equasion = "<"
    else
      equasion = "="
    end

    if spellFormula:len() > 0 then
      table.insert(currentSettings.spellTable,  {index = #currentSettings.spellTable+1, spell = spellFormula, sign = equasion, origin = source, cost = manaCost * 1000, value = spellTrigger, enabled = true})
      healWindow.healer.spells.spellFormula:setText('')
      healWindow.healer.spells.spellValue:setText('')
      healWindow.healer.spells.manaCost:setText('')
    end
    standBySpells = false
    standByItems = false
    refreshSpells()
  end

  healWindow.healer.items.addItem.onClick = function(widget)
 
    local id = healWindow.healer.items.itemId:getItemId()
    local trigger = tonumber(healWindow.healer.items.itemValue:getText())
    local src = healWindow.healer.items.itemSource:getCurrentOption().text
    local eq = healWindow.healer.items.itemCondition:getCurrentOption().text
    local source
    local equasion

    if not trigger then
      warn("HealBot: incorrect trigger value!")
      healWindow.healer.items.itemId:setItemId(0)
      healWindow.healer.items.itemValue:setText('')
      return
    end

    if src == "Current Mana" then
      source = "MP"
    elseif src == "Current Health" then
      source = "HP"
    elseif src == "Mana Percent" then
      source = "MP%"
    elseif src == "Health Percent" then
      source = "HP%"
    else
      source = "burst"
    end
    
    if eq == "Above" then
      equasion = ">"
    elseif eq == "Below" then
      equasion = "<"
    else
      equasion = "="
    end

    if id > 100 then
      table.insert(currentSettings.itemTable, {index = #currentSettings.itemTable+1,item = id, sign = equasion, origin = source, value = trigger, enabled = true})
      standBySpells = false
      standByItems = false
      refreshItems()
      healWindow.healer.items.itemId:setItemId(0)
      healWindow.healer.items.itemValue:setText('')
    end
  end

  healWindow.closeButton.onClick = function(widget)
    healWindow:hide()
  end

  local loadSettings = function()
    ui.title:setOn(currentSettings.enabled)
    healWindow.settings.profiles.Name:setText(currentSettings.name)
    refreshSpells()
    refreshItems()
    healWindow.settings.list.Visible:setChecked(currentSettings.Visible)
    healWindow.settings.list.Cooldown:setChecked(currentSettings.Cooldown)
    healWindow.settings.list.Delay:setChecked(currentSettings.Delay)
    healWindow.settings.list.MessageDelay:setChecked(currentSettings.MessageDelay)
    healWindow.settings.list.Interval:setChecked(currentSettings.Interval)
    healWindow.settings.list.Conditions:setChecked(currentSettings.Conditions)
  end
  loadSettings()

  local profileChange = function()
    setActiveProfile()
    activeProfileColor()
    loadSettings()
    vBotConfigSave("heal")
  end

  local resetSettings = function()
    currentSettings.enabled = false
    currentSettings.spellTable = {}
    currentSettings.itemTable = {}
    currentSettings.Visible = true
    currentSettings.Cooldown = true
    currentSettings.Delay = true
    currentSettings.MessageDelay = false
    currentSettings.Interval = true
    currentSettings.Conditions = true
    currentSettings.name = "Profile #" .. HealBotConfig.currentBotProfile
  end



  -- public functions
  HealBot = {} -- global table

  HealBot.isOn = function()
    return currentSettings.enabled
  end

  HealBot.isOff = function()
    return not currentSettings.enabled
  end

  HealBot.setOff = function()
    currentSettings.enabled = false
    ui.title:setOn(currentSettings.enabled)
    vBotConfigSave("atk")
  end

  HealBot.setOn = function()
    currentSettings.enabled = true
    ui.title:setOn(currentSettings.enabled)
    vBotConfigSave("atk")
  end

  HealBot.getActiveProfile = function()
    return HealBotConfig.currentHealBotProfile -- returns number 1-5
  end

  HealBot.setActiveProfile = function(n)
    if not n or not tonumber(n) or n < 1 or n > 5 then
      return error("[HealBot] wrong profile parameter! should be 1 to 5 is " .. n)
    else
      HealBotConfig.currentHealBotProfile = n
      profileChange()
    end
  end

  HealBot.show = function()
    healWindow:show()
    healWindow:raise()
    healWindow:focus()
  end
end

onTalk(function(name, level, mode, text, channelId, pos)
  for _, entry in pairs(currentSettings.spellTable) do
    if entry.enabled then
      if name ~= player:getName() then return end
      text = text:lower()
        if text == entry.spell then
          entry.totalcd = now + entry.cost
        end
      end
    end
  end)

-- spells
macro(1, function()
  if standBySpells then return end
  if not currentSettings.enabled then return end
  local somethingIsOnCooldown = false

  for _, entry in pairs(currentSettings.spellTable) do
    if entry.enabled and entry.totalcd <= now then
      if canCast(entry.spell, not currentSettings.Conditions, not currentSettings.Cooldown) then
        if entry.origin == "HP%" then
          if entry.sign == "=" and hppercent() == entry.value then
            say(entry.spell)
            schedule(1, function() say(entry.spell) end)
            schedule(1, function() say(entry.spell) end)
          elseif entry.sign == ">" and hppercent() >= entry.value then
            say(entry.spell)
            schedule(1, function() say(entry.spell) end)
            schedule(1, function() say(entry.spell) end)
          elseif entry.sign == "<" and hppercent() <= entry.value then
            say(entry.spell)
            schedule(1, function() say(entry.spell) end)
            schedule(1, function() say(entry.spell) end)
          end
        elseif entry.origin == "HP" then
          if entry.sign == "=" and hp() == entry.value then
            say(entry.spell)
            schedule(1, function() say(entry.spell) end)
            schedule(1, function() say(entry.spell) end)
          elseif entry.sign == ">" and hp() >= entry.value then
            say(entry.spell)
            schedule(1, function() say(entry.spell) end)
            schedule(1, function() say(entry.spell) end)
          elseif entry.sign == "<" and hp() <= entry.value then
            say(entry.spell)
            schedule(1, function() say(entry.spell) end)
            schedule(1, function() say(entry.spell) end)
          end
        elseif entry.origin == "MP%" then
          if entry.sign == "=" and manapercent() == entry.value then
            say(entry.spell)
            schedule(1, function() say(entry.spell) end)
            schedule(1, function() say(entry.spell) end)
          elseif entry.sign == ">" and manapercent() >= entry.value then
            say(entry.spell)
            schedule(1, function() say(entry.spell) end)
            schedule(1, function() say(entry.spell) end)
          elseif entry.sign == "<" and manapercent() <= entry.value then
            say(entry.spell)
            schedule(1, function() say(entry.spell) end)
            schedule(1, function() say(entry.spell) end)
          end
        elseif entry.origin == "MP" then
          if entry.sign == "=" and mana() == entry.value then
            say(entry.spell)
            schedule(1, function() say(entry.spell) end)
            schedule(1, function() say(entry.spell) end)
          elseif entry.sign == ">" and mana() >= entry.value then
            say(entry.spell)
            schedule(1, function() say(entry.spell) end)
            schedule(1, function() say(entry.spell) end)
          elseif entry.sign == "<" and mana() <= entry.value then
            say(entry.spell)
            schedule(1, function() say(entry.spell) end)
            schedule(1, function() say(entry.spell) end)
          end    
        elseif entry.origin == "burst" then
          if entry.sign == "=" and burstDamageValue() == entry.value then
            say(entry.spell)
            schedule(1, function() say(entry.spell) end)
            schedule(1, function() say(entry.spell) end)
          elseif entry.sign == ">" and burstDamageValue() >= entry.value then
            say(entry.spell)
            schedule(1, function() say(entry.spell) end)
            schedule(1, function() say(entry.spell) end)
          elseif entry.sign == "<" and burstDamageValue() <= entry.value then
            say(entry.spell)
            schedule(1, function() say(entry.spell) end)
            schedule(1, function() say(entry.spell) end)
          end    
        end
      end
    end
  end
end)

-- items
macro(1, function()
  if standByItems then return end
  if not currentSettings.enabled or #currentSettings.itemTable == 0 then return end
  if currentSettings.Delay and vBot.isUsing then return end
  if currentSettings.MessageDelay and vBot.isUsingPotion then return end

  if not currentSettings.MessageDelay then
    delay(400)
  end

  if TargetBot.isOn() and TargetBot.Looting.getStatus():len() > 0 and currentSettings.Interval then
    if not currentSettings.MessageDelay then
      delay(700)
    else
      delay(200)
    end
  end

  for _, entry in pairs(currentSettings.itemTable) do
    local item = findItem(entry.item)
    if (not currentSettings.Visible or item) and entry.enabled then
      if entry.origin == "HP%" then
        if entry.sign == "=" and hppercent() == entry.value then
          g_game.useInventoryItemWith(entry.item, player)
          schedule(1, function() g_game.useInventoryItemWith(entry.item, player) end)
          schedule(1, function() g_game.useInventoryItemWith(entry.item, player) end)
        elseif entry.sign == ">" and hppercent() >= entry.value then
          g_game.useInventoryItemWith(entry.item, player)
          schedule(1, function() g_game.useInventoryItemWith(entry.item, player) end)
          schedule(1, function() g_game.useInventoryItemWith(entry.item, player) end)
        elseif entry.sign == "<" and hppercent() <= entry.value then
          g_game.useInventoryItemWith(entry.item, player)
          schedule(1, function() g_game.useInventoryItemWith(entry.item, player) end)
          schedule(1, function() g_game.useInventoryItemWith(entry.item, player) end)
        end
      elseif entry.origin == "HP" then
        if entry.sign == "=" and hp() == tonumberentry.value then
          g_game.useInventoryItemWith(entry.item, player)
          schedule(1, function() g_game.useInventoryItemWith(entry.item, player) end)
          schedule(1, function() g_game.useInventoryItemWith(entry.item, player) end)
        elseif entry.sign == ">" and hp() >= entry.value then
          g_game.useInventoryItemWith(entry.item, player)
          schedule(1, function() g_game.useInventoryItemWith(entry.item, player) end)
          schedule(1, function() g_game.useInventoryItemWith(entry.item, player) end)
        elseif entry.sign == "<" and hp() <= entry.value then
          g_game.useInventoryItemWith(entry.item, player)
          schedule(1, function() g_game.useInventoryItemWith(entry.item, player) end)
          schedule(1, function() g_game.useInventoryItemWith(entry.item, player) end)
        end
      elseif entry.origin == "MP%" then
        if entry.sign == "=" and manapercent() == entry.value then
          g_game.useInventoryItemWith(entry.item, player)
          schedule(1, function() g_game.useInventoryItemWith(entry.item, player) end)
          schedule(1, function() g_game.useInventoryItemWith(entry.item, player) end)
        elseif entry.sign == ">" and manapercent() >= entry.value then
          g_game.useInventoryItemWith(entry.item, player)
          schedule(1, function() g_game.useInventoryItemWith(entry.item, player) end)
          schedule(1, function() g_game.useInventoryItemWith(entry.item, player) end)
        elseif entry.sign == "<" and manapercent() <= entry.value then
          g_game.useInventoryItemWith(entry.item, player)
          schedule(1, function() g_game.useInventoryItemWith(entry.item, player) end)
          schedule(1, function() g_game.useInventoryItemWith(entry.item, player) end)
        end
      elseif entry.origin == "MP" then
        if entry.sign == "=" and mana() == entry.value then
          g_game.useInventoryItemWith(entry.item, player)
          schedule(1, function() g_game.useInventoryItemWith(entry.item, player) end)
          schedule(1, function() g_game.useInventoryItemWith(entry.item, player) end)
        elseif entry.sign == ">" and mana() >= entry.value then
          g_game.useInventoryItemWith(entry.item, player)
          schedule(1, function() g_game.useInventoryItemWith(entry.item, player) end)
          schedule(1, function() g_game.useInventoryItemWith(entry.item, player) end)
        elseif entry.sign == "<" and mana() <= entry.value then
          g_game.useInventoryItemWith(entry.item, player)
          schedule(1, function() g_game.useInventoryItemWith(entry.item, player) end)
          schedule(1, function() g_game.useInventoryItemWith(entry.item, player) end)
        end   
      elseif entry.origin == "burst" then
        if entry.sign == "=" and burstDamageValue() == entry.value then
          g_game.useInventoryItemWith(entry.item, player)
          schedule(1, function() g_game.useInventoryItemWith(entry.item, player) end)
          schedule(1, function() g_game.useInventoryItemWith(entry.item, player) end)
        elseif entry.sign == ">" and burstDamageValue() >= entry.value then
          g_game.useInventoryItemWith(entry.item, player)
          schedule(1, function() g_game.useInventoryItemWith(entry.item, player) end)
          schedule(1, function() g_game.useInventoryItemWith(entry.item, player) end)
        elseif entry.sign == "<" and burstDamageValue() <= entry.value then
          g_game.useInventoryItemWith(entry.item, player)
          schedule(1, function() g_game.useInventoryItemWith(entry.item, player) end)
          schedule(1, function() g_game.useInventoryItemWith(entry.item, player) end)
        end   
      end
    end
  end
end)

onPlayerHealthChange(function(healthPercent)
  standByItems = false
  standBySpells = false
end)

onManaChange(function(player, mana, maxMana, oldMana, oldMaxMana)
  standByItems = false
  standBySpells = false
end)

-- FIM

-- BUFF

g_ui.loadUIFromString([[

BuffSpellSourceBoxPopupMenu < ComboBoxPopupMenu
BuffSpellSourceBoxPopupMenuButton < ComboBoxPopupMenuButton
BuffSpellSourceBox < ComboBox
  @onSetup: |
    self:addOption("Magic Level")
    self:addOption("Cooldown")
    self:addOption("isNotBuffed")


BuffSpellConditionBoxPopupMenu < ComboBoxPopupMenu
BuffSpellConditionBoxPopupMenuButton < ComboBoxPopupMenuButton
BuffSpellConditionBox < ComboBox
  @onSetup: |
    self:addOption("Below")

BuffEntry < Label
  background-color: alpha
  text-offset: 18 0
  focusable: true
  height: 16

  CheckBox
    id: enabled
    anchors.left: parent.left
    anchors.verticalCenter: parent.verticalCenter
    width: 15
    height: 15
    margin-top: 2
    margin-left: 3

  $focus:
    background-color: #00000055

  Button
    id: remove
    !text: tr('x')
    anchors.right: parent.right
    margin-right: 15
    width: 15
    height: 15

BuffItemEntry < Label
  background-color: alpha
  text-offset: 2 0
  focusable: true
  height: 16

  $focus:
    background-color: #00000055

  Button
    id: remove
    !text: tr('x')
    anchors.right: parent.right
    margin-right: 15
    width: 15
    height: 15                       

SpellBuffing < Panel
  image-source: /images/ui/panel_flat
  image-border: 6
  padding: 3
  size: 490 130

  Label
    id: whenSpell
    anchors.left: spellList.right
    anchors.top: parent.top
    text: When
    margin-top: 10
    margin-left: 7

  BuffSpellSourceBox
    id: spellSource
    anchors.top: parent.top
    anchors.left: whenSpell.right
    margin-top: 5
    margin-left: 35
    width: 128

  Label
    id: isSpell
    anchors.left: spellList.right
    anchors.top: whenSpell.bottom
    text: Is
    margin-top: 9
    margin-left: 7 

  BuffSpellConditionBox
    id: spellCondition
    anchors.left: spellSource.left
    anchors.top: spellSource.bottom   
    marin-top: 15
    width: 80

  TextEdit
    id: spellValue
    anchors.left: spellCondition.right
    anchors.top: spellCondition.top
    anchors.bottom: spellCondition.bottom
    width: 49

  Label
    id: castSpell
    anchors.left: isSpell.left
    anchors.top: isSpell.bottom
    text: Cast  
    margin-top: 9

  TextEdit
    id: spellFormula
    anchors.left: spellCondition.left
    anchors.top: spellCondition.bottom
    anchors.right: spellValue.right

  Label
    id: manaSpell
    anchors.left: castSpell.left
    anchors.top: castSpell.bottom
    text: Cooldown:
    margin-top: 8

  TextEdit
    id: manaCost
    anchors.left: spellFormula.left
    anchors.top: spellFormula.bottom
    width: 40 

  TextList
    id: spellList
    anchors.left: parent.left
    anchors.bottom: parent.bottom
    padding: 1
    size: 270 116    
    margin-bottom: 3
    margin-left: 3
    vertical-scrollbar: spellListScrollBar

  VerticalScrollBar
    id: spellListScrollBar
    anchors.top: spellList.top
    anchors.bottom: spellList.bottom
    anchors.right: spellList.right
    step: 14
    pixels-scroll: true

  Button
    id: addSpell
    anchors.right: spellFormula.right
    anchors.bottom: parent.bottom
    margin-bottom: 2
    margin-right: 10
    text: Add
    size: 40 17
    font: cipsoftFont

  Button
    id: MoveUp
    anchors.right: prev.left
    anchors.bottom: parent.bottom
    margin-bottom: 2
    margin-right: 5
    text: Move Up
    size: 55 17
    font: cipsoftFont

  Button
    id: MoveDown
    anchors.right: prev.left
    anchors.bottom: parent.bottom
    margin-bottom: 2
    margin-right: 5
    text: Move Down
    size: 55 17
    font: cipsoftFont  

BuffBotWindow < MainWindow
  !text: tr('Buffer Configuracao')
  size: 520 230
  color: darkRed
  @onEscape: self:hide()

  SpellBuffing
    id: spells
    anchors.top: parent.top
    anchors.left: parent.left

  HorizontalSeparator
    id: separator
    anchors.right: parent.right
    anchors.left: parent.left
    anchors.bottom: closeButton.top
    margin-bottom: 8    

  Button
    id: closeButton
    !text: tr('Close')
    font: cipsoftFont
    anchors.right: parent.right
    anchors.bottom: parent.bottom
    size: 45 21
    margin-top: 15
    margin-right: 5
]])

UI.Label("", rightPanel)
BuffBotPanelName = "buffbot"
local ui = setupUI([[
Panel
  height: 30

  Label 
    id: labelzz
    text: ~BUFF:
    anchors.top: parent.top
    anchors.left: parent.left
    margin-left: 50
    font: cipsoftFont
    color: #E0FFFF


  BotSwitch
    id: title
    anchors.top: labelzz.bottom 
    anchors.left: parent.left
    text-align: center
    width: 115
    color: yellow
    font: terminus-14px-bold

  Button
    id: buttonBuff
    anchors.top: prev.top
    anchors.left: prev.right
    anchors.right: parent.right
    margin-left: 6
    height: 17
    text: SETUP
    font: verdana-11px-rounded

]], rightPanel)
ui:setId(BuffBotPanelName)

if not storage[BuffBotPanelName] or not storage[BuffBotPanelName].spellTable then
  storage[BuffBotPanelName] = {
    enabled = false,
    spellTable = {}
  }
end

ui.title:setOn(storage[BuffBotPanelName].enabled)
ui.title.onClick = function(widget)
storage[BuffBotPanelName].enabled = not storage[BuffBotPanelName].enabled
widget:setOn(storage[BuffBotPanelName].enabled)
end

macro(1, function()
  if storage[BuffBotPanelName].enabled then
    ui.title:setText("ENABLED")
  else
    ui.title:setText("DISABLED")
  end
end)
ui.buttonBuff.onClick = function(widget)
  buffbotWindow:show()
  buffbotWindow:raise()
  buffbotWindow:focus()
end

rootWidget = g_ui.getRootWidget()
if rootWidget then
  buffbotWindow = g_ui.createWidget('BuffBotWindow', rootWidget)
  buffbotWindow:hide()

  local refreshSpells = function()
    if storage[BuffBotPanelName].spellTable and #storage[BuffBotPanelName].spellTable > 0 then
      for i, child in pairs(buffbotWindow.spells.spellList:getChildren()) do
        child:destroy()
      end
      for _, entry in pairs(storage[BuffBotPanelName].spellTable) do
        local label = g_ui.createWidget("BuffEntry", buffbotWindow.spells.spellList)
        label.enabled:setChecked(entry.enabled)
        label.enabled.onClick = function(widget)
          entry.enabled = not entry.enabled
          label.enabled:setChecked(entry.enabled)
        end
        label.remove.onClick = function(widget)
          table.removevalue(storage[BuffBotPanelName].spellTable, entry)
          reindexTable(storage[BuffBotPanelName].spellTable)
          label:destroy()
        end
        label:setColoredText({"[", "white", entry.value, "pink","] ", "white", entry.spell, "teal", " [", "white", (entry.cost/1000).. "s", "orange", "]", "white"})
      end
    end
  end
  refreshSpells()


  buffbotWindow.spells.MoveUp.onClick = function(widget)
    local input = buffbotWindow.spells.spellList:getFocusedChild()
    if not input then return end
    local index = buffbotWindow.spells.spellList:getChildIndex(input)
    if index < 2 then return end

    local move
    if storage[BuffBotPanelName].spellTable and #storage[BuffBotPanelName].spellTable > 0 then
      for _, entry in pairs(storage[BuffBotPanelName].spellTable) do
        if entry.index == index -1 then
          move = entry
        end
        if entry.index == index then
          move.index = index
          entry.index = index -1
        end
      end
    end
    table.sort(storage[BuffBotPanelName].spellTable, function(a,b) return a.index < b.index end)

    buffbotWindow.spells.spellList:moveChildToIndex(input, index - 1)
    buffbotWindow.spells.spellList:ensureChildVisible(input)
  end

  buffbotWindow.spells.MoveDown.onClick = function(widget)
    local input = buffbotWindow.spells.spellList:getFocusedChild()
    if not input then return end
    local index = buffbotWindow.spells.spellList:getChildIndex(input)
    if index >= buffbotWindow.spells.spellList:getChildCount() then return end

    local move
    local move2
    if storage[BuffBotPanelName].spellTable and #storage[BuffBotPanelName].spellTable > 0 then
      for _, entry in pairs(storage[BuffBotPanelName].spellTable) do
        if entry.index == index +1 then
          move = entry
        end
        if entry.index == index then
          move2 = entry
        end
      end
      if move and move2 then
        move.index = index
        move2.index = index + 1
      end
    end
    table.sort(storage[BuffBotPanelName].spellTable, function(a,b) return a.index < b.index end)

    buffbotWindow.spells.spellList:moveChildToIndex(input, index + 1)
    buffbotWindow.spells.spellList:ensureChildVisible(input)
  end

  buffbotWindow.spells.addSpell.onClick = function(widget)
 
    local spellFormula = buffbotWindow.spells.spellFormula:getText():trim()
    local manaCost = tonumber(buffbotWindow.spells.manaCost:getText())
    local spellTrigger = tonumber(buffbotWindow.spells.spellValue:getText())
    local spellSource = buffbotWindow.spells.spellSource:getCurrentOption().text
    local spellEquasion = buffbotWindow.spells.spellCondition:getCurrentOption().text
    local source
    local equasion

    if not manaCost then  
      warn("BuffBot: put a cooldown spell!")       
      buffbotWindow.spells.spellFormula:setText('')
      buffbotWindow.spells.spellValue:setText('')
      buffbotWindow.spells.manaCost:setText('') 
      return 
    end
    if not spellTrigger then  
      warn("BuffBot: incorrect cooldown value.") 
      buffbotWindow.spells.spellFormula:setText('')
      buffbotWindow.spells.spellValue:setText('')
      buffbotWindow.spells.manaCost:setText('')
      return 
    end

    if spellSource == "Magic Level" then
      source = "ML"
    end
    if spellSource == "Cooldown" then
      source = "CD"
    end
    if spellSource == "isNotBuffed" then
      source = "BUFFLESS"
    end
    if spellEquasion == "Below" then
      equasion = "<"
    end

    if spellFormula:len() > 0 then
      table.insert(storage[BuffBotPanelName].spellTable,  {totalcd = 0, index = #storage[BuffBotPanelName].spellTable+1, spell = spellFormula, sign = equasion, origin = source, cost = (manaCost * 1000), value = spellTrigger, enabled = true})
      buffbotWindow.spells.spellFormula:setText('')
      buffbotWindow.spells.spellValue:setText('')
      buffbotWindow.spells.manaCost:setText('')
    end
    refreshSpells()
  end
  end

  buffbotWindow.closeButton.onClick = function(widget)
    buffbotWindow:hide()
  end

onTalk(function(name, level, mode, text, channelId, pos)
  if not storage[BuffBotPanelName].enabled then return end
  for _, entry in pairs(storage[BuffBotPanelName].spellTable) do
    if name ~= player:getName() then return end
      text = text:lower()
      if text == entry.spell then
      entry.totalcd = now + entry.cost
      end
    end
  end)

-- spells
macro(1, function()
  if not storage[BuffBotPanelName].enabled then return end

  for _, entry in pairs(storage[BuffBotPanelName].spellTable) do
    if entry.enabled then
      if entry.origin == "ML" then
        if player:getMagicLevel() < entry.value then
          say(entry.spell)
        end
      elseif entry.origin == "CD" then
        if entry.totalcd < now then
          say(entry.spell)
        end
      elseif entry.origin == "BUFFLESS" then
        if not hasPartyBuff() then
          say(entry.spell)
        end
        end  
      end
    end  
end)

-- FIM

-- COMBO

g_ui.loadUIFromString([[

ComboEntry < Label
  background-color: alpha
  text-offset: 18 0
  focusable: true
  height: 16

  CheckBox
    id: enabled
    anchors.left: parent.left
    anchors.verticalCenter: parent.verticalCenter
    width: 15
    height: 15
    margin-top: 2
    margin-left: 3

  $focus:
    background-color: #00000055

  Button
    id: remove
    !text: tr('x')
    anchors.right: parent.right
    margin-right: 15
    width: 15
    height: 15

ComboItemEntry < Label
  background-color: alpha
  text-offset: 2 0
  focusable: true
  height: 16

  $focus:
    background-color: #00000055

  Button
    id: remove
    !text: tr('x')
    anchors.right: parent.right
    margin-right: 15
    width: 15
    height: 15                       

SpellComboing < Panel
  image-source: /images/ui/panel_flat
  image-border: 6
  padding: 3
  size: 490 130

  Label
    id: castSpell
    anchors.left: spellList.right
    anchors.top: parent.top
    text: Cast:
    margin-top: 9
    margin-left: 10

  TextEdit
    id: spellFormula
    anchors.left: MoveUp.left
    anchors.top: castSpell.top

  Label
    id: manaSpell
    anchors.left: castSpell.left
    anchors.top: castSpell.bottom
    text: Cooldown:
    margin-top: 8

  TextEdit
    id: manaCost
    anchors.left: spellFormula.left
    anchors.top: spellFormula.bottom
    width: 40 

  CheckBox
    id: atkfriend
    anchors.top: manaSpell.bottom
    anchors.left: manaSpell.left
    margin-right: 10
    margin-top: 20

  Label 
    id: atkfriendlabel
    text: Don't attack friends.
    anchors.top: atkfriend.top 
    anchors.left: atkfriend.right 
    margin-left: 10

  TextList
    id: spellList
    anchors.left: parent.left
    anchors.bottom: parent.bottom
    padding: 1
    size: 270 116    
    margin-bottom: 3
    margin-left: 3
    vertical-scrollbar: spellListScrollBar

  VerticalScrollBar
    id: spellListScrollBar
    anchors.top: spellList.top
    anchors.bottom: spellList.bottom
    anchors.right: spellList.right
    step: 14
    pixels-scroll: true

  Button
    id: addSpell
    anchors.right: parent.right
    anchors.bottom: parent.bottom
    margin-bottom: 2
    margin-right: 10
    text: Add
    size: 40 17
    font: cipsoftFont

  Button
    id: MoveUp
    anchors.right: addSpell.left
    anchors.bottom: parent.bottom
    margin-bottom: 2
    margin-right: 5
    text: Move Up
    size: 55 17
    font: cipsoftFont

  Button
    id: MoveDown
    anchors.right: MoveUp.left
    anchors.bottom: parent.bottom
    margin-bottom: 2
    margin-right: 5
    text: Move Down
    size: 55 17
    font: cipsoftFont  

ComboBotWindow < MainWindow
  !text: tr('Combo Configuracao')
  size: 520 230
  color: darkRed
  @onEscape: self:hide()

  SpellComboing
    id: spells
    anchors.top: parent.top
    anchors.left: parent.left

  HorizontalSeparator
    id: separator
    anchors.right: parent.right
    anchors.left: parent.left
    anchors.bottom: closeButton.top
    margin-bottom: 8    

  Button
    id: closeButton
    !text: tr('Close')
    font: cipsoftFont
    anchors.right: parent.right
    anchors.bottom: parent.bottom
    size: 45 21
    margin-top: 15
    margin-right: 5
]])

UI.Label("", rightPanel)
ComboBotPanelName = "ComboBot"
local ui = setupUI([[
Panel
  height: 30

  Label
    id: label 
    text: ~COMBO:
    anchors.top: parent.top 
    anchors.left: parent.left
    margin-left: 50
    font: cipsoftFont
    color: #E0FFFF

  BotSwitch
    id: title
    anchors.top: label.bottom
    anchors.left: parent.left
    text-align: center
    width: 115
    !text: tr('COMBO')
    color: yellow
    font: terminus-14px-bold

  Button
    id: buttonCombo
    anchors.top: prev.top
    anchors.left: prev.right
    anchors.right: parent.right
    margin-left: 6
    height: 17
    text: SETUP
    font: verdana-11px-rounded

]], rightPanel)
ui:setId(ComboBotPanelName)

if not storage[ComboBotPanelName] or not storage[ComboBotPanelName].spellTable then
  storage[ComboBotPanelName] = {
    enabled = false,
    spellTable = {},
    atkfriend = false
  }
end

ui.title:setOn(storage[ComboBotPanelName].enabled)
ui.title.onClick = function(widget)
storage[ComboBotPanelName].enabled = not storage[ComboBotPanelName].enabled
widget:setOn(storage[ComboBotPanelName].enabled)
end


ui.buttonCombo.onClick = function(widget)
  ComboBotWindow:show()
  ComboBotWindow:raise()
  ComboBotWindow:focus()
end

macro(1, function()
if storage[ComboBotPanelName].enabled then
  ui.title:setText("ENABLED")
else
  ui.title:setText("DISABLED")
end
end)

rootWidget = g_ui.getRootWidget()
if rootWidget then
  ComboBotWindow = g_ui.createWidget('ComboBotWindow', rootWidget)
  ComboBotWindow:hide()

  local refreshSpells = function()
    if storage[ComboBotPanelName].spellTable and #storage[ComboBotPanelName].spellTable > 0 then
      for i, child in pairs(ComboBotWindow.spells.spellList:getChildren()) do
        child:destroy()
      end
      for _, entry in pairs(storage[ComboBotPanelName].spellTable) do
        local label = g_ui.createWidget("ComboEntry", ComboBotWindow.spells.spellList)
        label.enabled:setChecked(entry.enabled)
        label.enabled.onClick = function(widget)
          entry.enabled = not entry.enabled
          label.enabled:setChecked(entry.enabled)
        end
        label.remove.onClick = function(widget)
          table.removevalue(storage[ComboBotPanelName].spellTable, entry)
          reindexTable(storage[ComboBotPanelName].spellTable)
          label:destroy()
        end
        label:setColoredText({"[", "white", entry.spell, "teal", "] ", "white", "CD: ", "white", (entry.cost/1000).. "s", "orange"})
      end
    end
  end
  refreshSpells()


  ComboBotWindow.spells.MoveUp.onClick = function(widget)
    local input = ComboBotWindow.spells.spellList:getFocusedChild()
    if not input then return end
    local index = ComboBotWindow.spells.spellList:getChildIndex(input)
    if index < 2 then return end

    local move
    if storage[ComboBotPanelName].spellTable and #storage[ComboBotPanelName].spellTable > 0 then
      for _, entry in pairs(storage[ComboBotPanelName].spellTable) do
        if entry.index == index -1 then
          move = entry
        end
        if entry.index == index then
          move.index = index
          entry.index = index -1
        end
      end
    end
    table.sort(storage[ComboBotPanelName].spellTable, function(a,b) return a.index < b.index end)

    ComboBotWindow.spells.spellList:moveChildToIndex(input, index - 1)
    ComboBotWindow.spells.spellList:ensureChildVisible(input)
  end

  ComboBotWindow.spells.MoveDown.onClick = function(widget)
    local input = ComboBotWindow.spells.spellList:getFocusedChild()
    if not input then return end
    local index = ComboBotWindow.spells.spellList:getChildIndex(input)
    if index >= ComboBotWindow.spells.spellList:getChildCount() then return end

    local move
    local move2
    if storage[ComboBotPanelName].spellTable and #storage[ComboBotPanelName].spellTable > 0 then
      for _, entry in pairs(storage[ComboBotPanelName].spellTable) do
        if entry.index == index +1 then
          move = entry
        end
        if entry.index == index then
          move2 = entry
        end
      end
      if move and move2 then
        move.index = index
        move2.index = index + 1
      end
    end
    table.sort(storage[ComboBotPanelName].spellTable, function(a,b) return a.index < b.index end)

    ComboBotWindow.spells.spellList:moveChildToIndex(input, index + 1)
    ComboBotWindow.spells.spellList:ensureChildVisible(input)
  end

  ComboBotWindow.spells.addSpell.onClick = function(widget)
 
    local spellFormula = ComboBotWindow.spells.spellFormula:getText():trim()
    local manaCost = tonumber(ComboBotWindow.spells.manaCost:getText())
    local spellTrigger = 0
    local spellSource = 0
    local spellEquasion = 0
    local source
    local equasion

    if not manaCost then  
      warn("ComboBot: put a cooldown spell!")       
      ComboBotWindow.spells.spellFormula:setText('')
      ComboBotWindow.spells.manaCost:setText('') 
      return 
    end
    if not spellTrigger then  
      warn("ComboBot: incorrect cooldown value.") 
      ComboBotWindow.spells.spellFormula:setText('')
      ComboBotWindow.spells.manaCost:setText('')
      return 
    end


    if spellFormula:len() > 0 then
      table.insert(storage[ComboBotPanelName].spellTable,  {totalcd = 0, index = #storage[ComboBotPanelName].spellTable+1, spell = spellFormula, sign = equasion, origin = source, cost = (manaCost * 1000), enabled = true})
      ComboBotWindow.spells.spellFormula:setText('')
      ComboBotWindow.spells.manaCost:setText('')
    end
    refreshSpells()
  end
  end

  ComboBotWindow.closeButton.onClick = function(widget)
    ComboBotWindow:hide()
  end

ComboBotWindow.spells.atkfriend:setChecked(storage[ComboBotPanelName].atkfriend)
ComboBotWindow.spells.atkfriend.onClick = function(widget)
  storage[ComboBotPanelName].atkfriend = not storage[ComboBotPanelName].atkfriend
      widget:setChecked(storage[ComboBotPanelName].atkfriend)
    end


onTalk(function(name, level, mode, text, channelId, pos)
  if not storage[ComboBotPanelName].enabled then return end
  for _, entry in pairs(storage[ComboBotPanelName].spellTable) do
    if name ~= player:getName() then return end
      text = text:lower()
      if text == entry.spell then
      entry.totalcd = now + entry.cost
      end
    end
  end)

-- spells
macro(1, function()
  mob = g_game.getAttackingCreature()
  if not storage[ComboBotPanelName].enabled then return end

  for _, entry in pairs(storage[ComboBotPanelName].spellTable) do
    if entry.enabled then
        if g_game.isAttacking() then
          if tonumber(entry.totalcd) <= now then
            if storage[ComboBotPanelName].atkfriend then
              if mob:getShield() <= 0 or mob:getEmblem() == 1 then 
              say(entry.spell)
              schedule(1, function() say(entry.spell) end)
              end
            else
              say(entry.spell)
              schedule(1, function() say(entry.spell) end)
        end
      end
    end
  end
end
end)

-- FIM

-- TIMESPELL

UI.Label("", rightPanel)
timeSpellPanelName = "timespellbot"
local ui = setupUI([[
Panel
  height: 30

  Label 
    id: label 
    text: ~TIMESPELL:
    anchors.top: parent.top 
    anchors.left: parent.left 
    margin-left: 50
    font: cipsoftFont
    color: #E0FFFF

  BotSwitch
    id: title
    anchors.top: label.bottom
    anchors.left: parent.left
    text-align: center
    width: 115
    font: terminus-14px-bold
    color: yellow

  Button
    id: settings
    anchors.top: prev.top
    anchors.left: prev.right
    anchors.right: parent.right
    margin-left: 6
    height: 17
    text: NEW
    font: verdana-11px-rounded

]], rightPanel)
ui:setId(timeSpellPanelName);
local windowUI = setupUI([[
MainWindow
  !text: tr('Time Spell by neoX - Discord: VictorNeox#1947')
  size: 820 312
  
  Panel
    id: MainPanel
    image-source: /images/ui/panel_flat
    anchors.top: parent.top
    anchors.left: parent.left
    image-border: 6
    padding: 3
    size: 492 225

    
    TextList
      id: spellList
      anchors.left: parent.left
      anchors.bottom: parent.bottom
      padding: 1
      size: 270 212    
      margin-bottom: 3
      margin-left: 3
      vertical-scrollbar: spellListScrollBar
      
    VerticalScrollBar
      id: spellListScrollBar
      anchors.top: spellList.top
      anchors.bottom: spellList.bottom
      anchors.right: spellList.right
      step: 14
      pixels-scroll: true

    Label
      id: spellNameLabel
      anchors.left: spellList.right
      anchors.top: spellList.top
      text: Spell:
      margin-top: 10
      margin-left: 7

    TextEdit
      id: spellName
      anchors.left: spellNameLabel.right
      anchors.top: parent.top
      margin-top: 5
      margin-left: 12
      width: 125

    Label
      id: onScreenLabel
      anchors.left: spellNameLabel.left
      anchors.top: spellName.bottom
      margin-top: 10
      text: OnScreen:

    TextEdit
      id: onScreen
      anchors.left: onScreenLabel.right
      anchors.top: prev.top
      margin-top: -5
      margin-left: 17
      width: 125

    Label
      id: activeTimeLabel
      anchors.left: onScreenLabel.left
      anchors.top: onScreen.bottom
      text: During:
      margin-top: 10

    TextEdit
      id: activeTime
      anchors.left: activeTimeLabel.right
      anchors.top: prev.top
      margin-top: -5
      margin-left: 5
      width: 125

    Label
      id: totalTimeLabel
      anchors.left: activeTimeLabel.left
      anchors.top: activeTime.bottom
      text: Total CD:
      margin-top: 10

    TextEdit
      id: totalTime
      anchors.left: totalTimeLabel.right
      anchors.top: prev.top
      margin-top: -5
      margin-left: 13
      width: 125

    Label
      id: posXLabel
      anchors.left: totalTimeLabel.left
      anchors.top: totalTime.bottom
      text: X:
      margin-top: 10

    TextEdit
      id: posX
      anchors.left: posXLabel.right
      anchors.top: prev.top
      margin-top: -5
      margin-left: 68
      width: 35

    Label
      id: posYLabel
      anchors.left: posX.right
      anchors.top: posX.top
      text: Y:
      margin-top: 5
      margin-left: 25

    TextEdit
      id: posY
      anchors.left: posYLabel.right
      anchors.top: prev.top
      margin-top: -5
      margin-left: 21
      width: 35

    Button
      id: addSpell
      anchors.left: spellList.right
      anchors.bottom: parent.bottom
      margin-bottom: 2
      margin-left: 8
      text: Add
      size: 200 17
      font: cipsoftFont

  VerticalSeparator
    id: sep
    anchors.top: parent.top
    anchors.left: prev.right
    anchors.bottom: MainPanel.bottom
    margin-left: 10
    margin-bottom: 5
    
  Label
    anchors.left: prev.right
    anchors.right: parent.right
    anchors.top: parent.top
    text-align: center
    text: Informacoes Adicionais

  HorizontalSeparator
    anchors.left: prev.left
    anchors.top: prev.bottom  
    anchors.right: prev.right
    margin-top: 5
    margin-left: 10

  Label 
    id: FirstAditionalLabel
    anchors.top: prev.bottom
    anchors.left: prev.left
    margin-top: 10
    margin-left: 5
    text: Spell - Mensagem laranja acima do char.

  Label 
    anchors.top: prev.bottom
    anchors.left: prev.left
    margin-top: 10
    text: OnScreen - Nome a ser exibido na sua tela.

  Label 
    anchors.top: prev.bottom
    anchors.left: prev.left
    margin-top: 10
    text: During - Duracao do buff/debuff.

  Label 
    anchors.top: prev.bottom
    anchors.left: prev.left
    margin-top: 10
    text: Total CD - Cooldown total da magia.

  Label 
    anchors.top: prev.bottom
    anchors.left: prev.left
    margin-top: 10
    text: X/Y - Coloque 100 e mova a TS com o mouse.

  HorizontalSeparator
    id: separator
    anchors.right: parent.right
    anchors.left: parent.left
    anchors.bottom: closeButton.top
    margin-bottom: 8    

  Button
    id: closeButton
    !text: tr('Close')
    font: cipsoftFont
    anchors.right: parent.right
    anchors.bottom: parent.bottom
    size: 45 21
    margin-top: 15
    margin-right: 5
      
]], g_ui.getRootWidget());
windowUI:hide();
local configName = modules.game_bot.contentsPanel.config:getCurrentOption().text;
TimeSpellConfig = {
    spells = {},
};

local spellsWidgets = {};

local timeSpellFile = "/bot/" .. configName .. "/".. name() .. "_TimeSpell.json";
local MainPanel = windowUI.MainPanel;

local editActiveTime = nil;
local editTotalTime = nil;

if g_resources.fileExists(timeSpellFile) then
    local status, result = pcall(function() 
      return json.decode(g_resources.readFileContents(timeSpellFile)) 
    end)
    if not status then
      return onError("Error loading file (" .. timeSpellFile .. "). To fix the problem, delete TimeSpell.json. Details:" .. result)
    end
    TimeSpellConfig = result
    if (type(TimeSpellConfig.spells) ~= 'table') then
        TimeSpellConfig.spells = {};
    end

    for i, object in pairs(TimeSpellConfig.spells) do
        if (object.totalCd - now > object.totalTime) then
            TimeSpellConfig.spells[i].totalCd = 0;
            TimeSpellConfig.spells[i].activeCd = 0;
        end
    end
end

function timeSpellConfigSave()
    local configFile =  timeSpellFile;

    local status, result = pcall(function() 
        return json.encode(TimeSpellConfig, 2) 
    end);

    if not status then
        return onError("Error saving configuration. Details: " .. result);
    end
      
    if result:len() > 100 * 1024 * 1024 then
        return onError("Configuration file over 100MB will not be saved.");
    end

    g_resources.writeFileContents(timeSpellFile, result);
end

ui.title:setOn(TimeSpellConfig.enabled);
ui.title.onClick = function(widget)
    TimeSpellConfig.enabled = not TimeSpellConfig.enabled;
    widget:setOn(TimeSpellConfig.enabled);

    timeSpellConfigSave();

    if (not TimeSpellConfig.enabled) then
        for i, widget in pairs(spellsWidgets) do
            if (widget ~= nil) then
                spellsWidgets[i]:destroy();
                spellsWidgets[i] = nil;
            end
        end
    end
end

macro(1, function()
if ui.title:isOn() then 
  ui.title:setText("ENABLED")
else
  ui.title:setText("DISABLED")
end
end)

ui.settings.onClick = function(widget)
    windowUI:show();
    windowUI:raise();
    windowUI:focus();
end
windowUI.closeButton.onClick = function(widget)
    windowUI:hide();
    timeSpellConfigSave();
end

local destroySpellWidget = function(key)
    spellsWidgets[key]:destroy();
    spellsWidgets[key] = nil;
end

local refreshSpells = function()
    if TimeSpellConfig.spells then
      for i, child in pairs(MainPanel.spellList:getChildren()) do
        child:destroy();
      end
      for _, entry in pairs(TimeSpellConfig.spells) do
        local label = UI.createWidget('SpellEntry', MainPanel.spellList);
        label.onDoubleClick = function(widget)
            local spellTable = entry;
            TimeSpellConfig.spells[entry.spell] = nil;
            reindexTable(TimeSpellConfig.spells);
            if (spellsWidgets[spellTable.spell] ~= nil) then
                spellsWidgets[spellTable.spell]:destroy();
                spellsWidgets[spellTable.spell] = nil;
            end
            MainPanel.spellName:setText(spellTable.spell);
            MainPanel.onScreen:setText(spellTable.onScreen);
            MainPanel.activeTime:setText(spellTable.activeTime);
            MainPanel.totalTime:setText(spellTable.totalTime);
            MainPanel.posX:setText(spellTable.x);
            MainPanel.posY:setText(spellTable.y);
            label:destroy();
        end
        label.enabled:setChecked(entry.enabled);
        label.enabled.onClick = function(widget)
          entry.enabled = not entry.enabled;
          label.enabled:setChecked(entry.enabled);
        end
        label.remove.onClick = function(widget)
          TimeSpellConfig.spells[entry.spell] = nil;
          destroySpellWidget(entry.spell);
          reindexTable(TimeSpellConfig.spells);
          label:destroy();
        end
        label:setText('['.. entry.onScreen .. ']: Cooldown: ' .. entry.totalTime / 1000 .. 's');
      end
    end
end

refreshSpells();

MainPanel.addSpell.onClick = function(widget)

    local spellName = MainPanel.spellName:getText():trim():lower();
    local onScreenName = MainPanel.onScreen:getText():trim();
    local activeTime = tonumber(MainPanel.activeTime:getText()) or 0;
    local totalTime = tonumber(MainPanel.totalTime:getText());
    local posX = tonumber(MainPanel.posX:getText()) or 0;
    local posY = tonumber(MainPanel.posY:getText()) or 39;

    if (not totalTime) then
        return warn('TimeSpell: Enter a valid cooldown.');
    end

    if (not posX) then
        return warn('TimeSpell: Enter a valid Y position.');
    end

    if (not posY) then
        return warn('TimeSpell: Enter a valid Y position.');
    end

    if (spellName:len() == 0) then
        return warn('TimeSpell: Enter a valid spell.');
    end

    if (onScreenName:len() == 0) then
        return warn('TimeSpell: Put a name on OnScreen.');
    end

    TimeSpellConfig.spells[spellName] = { 
      index = #TimeSpellConfig.spells+1, 
      spell = spellName, 
      onScreen = onScreenName, 
      activeTime = activeTime,
      activeCd = 0,
      totalTime = totalTime,
      totalCd = 0,
      x = posX,
      y = posY,
      enabled = true,
    };

    MainPanel.spellName:setText('');
    MainPanel.onScreen:setText('');
    MainPanel.activeTime:setText('');
    MainPanel.totalTime:setText('');
    MainPanel.posX:setText('');
    MainPanel.posY:setText('');
    refreshSpells();
end

local spellWidget = [[
UIWidget
  background-color: #00000090
  opacity: 0.87
  padding: 0 5
  focusable: true
  phantom: false
  draggable: true
]];

local function formatRemainingTime(time)
    local remainingTime = (time - now) / 1000;
    local timeText = '';
    timeText = string.format("%.0f", (time - now) / 1000).. "s";
    return timeText;
end

local function attachSpellWidgetCallbacks(key)
    spellsWidgets[key].onDragEnter = function(widget, mousePos)
        if not modules.corelib.g_keyboard.isCtrlPressed() then
          return false
        end
        widget:breakAnchors()
        widget.movingReference = { x = mousePos.x - widget:getX(), y = mousePos.y - widget:getY() }
        return true
    end
  
    spellsWidgets[key].onDragMove = function(widget, mousePos, moved)
        local parentRect = widget:getParent():getRect()
        local x = math.min(math.max(parentRect.x, mousePos.x - widget.movingReference.x), parentRect.x + parentRect.width - widget:getWidth())
        local y = math.min(math.max(parentRect.y - widget:getParent():getMarginTop(), mousePos.y - widget.movingReference.y), parentRect.y + parentRect.height - widget:getHeight())        
        widget:move(x, y)
        return true
    end
  
    spellsWidgets[key].onDragLeave = function(widget, pos)
      TimeSpellConfig.spells[key].x = widget:getX();
      TimeSpellConfig.spells[key].y = widget:getY();
      timeSpellConfigSave();
      return true
    end
end

local TimeSpellMacro = macro(100, function() 
    if (not ui.title:isOn()) then return; end

    for index, object in pairs(TimeSpellConfig.spells) do
      if (not object.enabled and spellsWidgets[object.spell] ~= nil) then
          spellsWidgets[object.spell]:destroy();
          spellsWidgets[object.spell] = nil;
      elseif (object.enabled) then
          if (spellsWidgets[object.spell] == nil) then
              spellsWidgets[object.spell] = setupUI(spellWidget, g_ui.getRootWidget());
              spellsWidgets[object.spell]:setPosition({ x = object.x, y = object.y })
              attachSpellWidgetCallbacks(object.spell);
          end
          
          if (not object.totalCd or object.totalCd < now) then
              spellsWidgets[object.spell]:setFont("sans-bold-16px")
              spellsWidgets[object.spell]:setWidth(200)
              spellsWidgets[object.spell]:setText(object.onScreen .. ': Pronto');
              spellsWidgets[object.spell]:setColor('#EBDAA2');

          elseif (object.activeCd >= now) then
              spellsWidgets[object.spell]:setColor('#66B2FF');
              spellsWidgets[object.spell]:setFont("sans-bold-16px")
              local timeText = formatRemainingTime(object.activeCd);
              spellsWidgets[object.spell]:setText(object.onScreen .. ': ' .. timeText);
          else
              spellsWidgets[object.spell]:setColor('#FF6666');
              spellsWidgets[object.spell]:setFont("sans-bold-16px")
              local timeText = formatRemainingTime(object.totalCd);
              spellsWidgets[object.spell]:setText(object.onScreen .. ': ' .. timeText);
          end
      end
    end
end);

onTalk(function(name, level, mode, text, channelId, pos)
    if (name ~= player:getName()) then return; end

    text = text:lower();
    if (TimeSpellConfig.spells[text] == nil) then return; end
    if (TimeSpellConfig.spells[text].activeTime > 0) then
        TimeSpellConfig.spells[text].activeCd = now + TimeSpellConfig.spells[text].activeTime;
    end
    TimeSpellConfig.spells[text].totalCd = now + TimeSpellConfig.spells[text].totalTime;
    timeSpellConfigSave();
end);


-- mousebot

g_ui.loadUIFromString([[
MouseSourceBoxPopupMenu < ComboBoxPopupMenu
MouseSourceBoxPopupMenuButton < ComboBoxPopupMenuButton
MouseSourceBox < ComboBox
  @onSetup: |
    self:addOption("Scroll Up")
    self:addOption("Scroll Down")
    self:addOption("MButton1")
    self:addOption("MButton2")

MouseHealEntry < Label
  background-color: alpha
  text-offset: 18 0
  focusable: true
  height: 16

  CheckBox
    id: enabled
    anchors.left: parent.left
    anchors.verticalCenter: parent.verticalCenter
    width: 15
    height: 15
    margin-top: 2
    margin-left: 3

  $focus:
    background-color: #00000055

  Button
    id: remove
    !text: tr('x')
    anchors.right: parent.right
    margin-right: 15
    width: 15
    height: 15

MouseItemEntry < Label
  background-color: alpha
  text-offset: 2 0
  focusable: true
  height: 16

  $focus:
    background-color: #00000055

  Button
    id: remove
    !text: tr('x')
    anchors.right: parent.right
    margin-right: 15
    width: 15
    height: 15                       

SpellMouse < Panel
  image-source: /images/ui/panel_flat
  image-border: 6
  padding: 3
  size: 490 130

  Label
    id: whenSpell
    anchors.left: spellList.right
    anchors.top: parent.top
    text: When:
    margin-top: 10
    margin-left: 7

  MouseSourceBox
    id: spellSource
    anchors.top: parent.top
    anchors.left: whenSpell.right
    margin-top: 5
    margin-left: 35
    width: 128

  Label
    id: castSpell
    anchors.left: spellList.right
    anchors.top: whenSpell.bottom
    text: Cast:
    margin-top: 9
    margin-left: 7

  TextEdit
    id: spellFormula
    anchors.left: spellSource.left
    anchors.top: spellSource.bottom
    anchors.right: spellValue.right


  TextList
    id: spellList
    anchors.left: parent.left
    anchors.bottom: parent.bottom
    padding: 1
    size: 270 116    
    margin-bottom: 3
    margin-left: 3
    vertical-scrollbar: spellListScrollBar

  VerticalScrollBar
    id: spellListScrollBar
    anchors.top: spellList.top
    anchors.bottom: spellList.bottom
    anchors.right: spellList.right
    step: 14
    pixels-scroll: true

  Button
    id: addSpell
    anchors.right: parent.right
    anchors.bottom: parent.bottom
    margin-bottom: 2
    margin-right: 10
    text: Add
    size: 40 17
    font: cipsoftFont

  Button
    id: MoveUp
    anchors.right: prev.left
    anchors.bottom: parent.bottom
    margin-bottom: 2
    margin-right: 5
    text: Move Up
    size: 55 17
    font: cipsoftFont

  Button
    id: MoveDown
    anchors.right: prev.left
    anchors.bottom: parent.bottom
    margin-bottom: 2
    margin-right: 5
    text: Move Down
    size: 55 17
    font: cipsoftFont  

ItemMouse < Panel
  image-source: /images/ui/panel_flat
  image-border: 6
  padding: 3
  size: 490 130

  Label
    id: whenItem
    anchors.left: itemList.right
    anchors.top: parent.top
    text: When:
    margin-top: 10
    margin-left: 7

  MouseSourceBox
    id: itemSource
    anchors.top: parent.top
    anchors.left: whenItem.right
    margin-top: 5
    margin-left: 35
    width: 128


  Label
    id: useItem
    anchors.left: itemList.right
    anchors.top: whenItem.bottom
    text: Use:
    margin-left: 50
    margin-top: 40

  BotItem
    id: itemId
    anchors.left: useItem.right
    anchors.top: itemSource.bottom
    margin-left: 30
    margin-top: 24

  TextList
    id: itemList
    anchors.left: parent.left
    anchors.bottom: parent.bottom
    padding: 1
    size: 270 116  
    margin-top: 3
    margin-bottom: 3
    margin-left: 3
    vertical-scrollbar: itemListScrollBar

  VerticalScrollBar
    id: itemListScrollBar
    anchors.top: itemList.top
    anchors.bottom: itemList.bottom
    anchors.right: itemList.right
    step: 14
    pixels-scroll: true

  Button
    id: addItem
    anchors.right: parent.right
    anchors.bottom: parent.bottom
    margin-bottom: 2
    margin-right: 10
    text: Add
    size: 40 17
    font: cipsoftFont

  Button
    id: MoveUp
    anchors.right: prev.left
    anchors.bottom: parent.bottom
    margin-bottom: 2
    margin-right: 5
    text: Move Up
    size: 55 17
    font: cipsoftFont

  Button
    id: MoveDown
    anchors.right: prev.left
    anchors.bottom: parent.bottom
    margin-bottom: 2
    margin-right: 5
    text: Move Down
    size: 55 17
    font: cipsoftFont 

MouseWindow < MainWindow
  !text: tr('Mouse Bot')
  size: 520 350
  @onEscape: self:hide()

  SpellMouse
    id: spells
    anchors.top: parent.top
    anchors.left: parent.left

  ItemMouse
    id: items
    anchors.top: prev.bottom
    anchors.left: parent.left
    margin-top: 10

  HorizontalSeparator
    id: separator
    anchors.right: parent.right
    anchors.left: parent.left
    anchors.bottom: closeButton.top
    margin-bottom: 8    

  Button
    id: closeButton
    !text: tr('Close')
    font: cipsoftFont
    anchors.right: parent.right
    anchors.bottom: parent.bottom
    size: 45 21
    margin-top: 15
    margin-right: 5

]])

UI.Label("", rightPanel)
storage.lootStatus = ""
MousePanelName = "Mousebot"
local ui = setupUI([[
Panel
  height: 30

  Label 
    id: label 
    text: ~ MouseBot:
    anchors.top: parent.top 
    anchors.left: parent.left 
    margin-left: 50
    font: cipsoftFont
    color: #E0FFFF

  BotSwitch
    id: title
    anchors.top: label.bottom
    anchors.left: parent.left
    text-align: center
    width: 115
    font: terminus-14px-bold
    color: yellow

  Button
    id: combos
    anchors.top: prev.top
    anchors.left: prev.right
    anchors.right: parent.right
    margin-left: 3
    height: 17
    text: SETUP 
    font: verdana-11px-rounded

]], rightPanel)
ui:setId(MousePanelName)

if not storage[MousePanelName] or not storage[MousePanelName].spellTable or not storage[MousePanelName].itemTable then
  storage[MousePanelName] = {
    enabled = false,
    spellTable = {},
    itemTable = {}
  }
end

ui.title:setOn(storage[MousePanelName].enabled)
ui.title.onClick = function(widget)
storage[MousePanelName].enabled = not storage[MousePanelName].enabled
widget:setOn(storage[MousePanelName].enabled)
end

macro(1, function()
  if ui.title:isOn() then 
    ui.title:setText("ENABLED")
  else 
    ui.title:setText("DISABLED")
  end
end)

ui.combos.onClick = function(widget)
  MouseWindow:show()
  MouseWindow:raise()
  MouseWindow:focus()
end


rootWidget = g_ui.getRootWidget()
if rootWidget then
  MouseWindow = g_ui.createWidget('MouseWindow', rootWidget)
  MouseWindow:hide()

  local refreshSpells = function()
    if storage[MousePanelName].spellTable and #storage[MousePanelName].spellTable > 0 then
      for i, child in pairs(MouseWindow.spells.spellList:getChildren()) do
        child:destroy()
      end
      for _, entry in pairs(storage[MousePanelName].spellTable) do
        local label = g_ui.createWidget("SpellEntry", MouseWindow.spells.spellList)
        label.enabled:setChecked(entry.enabled)
        label.enabled.onClick = function(widget)
          entry.enabled = not entry.enabled
          label.enabled:setChecked(entry.enabled)
        end
        label.remove.onClick = function(widget)
          table.removevalue(storage[MousePanelName].spellTable, entry)
          reindexTable(storage[MousePanelName].spellTable)
          label:destroy()
        end
        label:setText(entry.origin.. ": ".. entry.spell)
      end
    end
  end
  refreshSpells()

  local refreshItems = function()
    if storage[MousePanelName].itemTable and #storage[MousePanelName].itemTable > 0 then
      for i, child in pairs(MouseWindow.items.itemList:getChildren()) do
        child:destroy()
      end
      for _, entry in pairs(storage[MousePanelName].itemTable) do
        local label = g_ui.createWidget("SpellEntry", MouseWindow.items.itemList)
        label.enabled:setChecked(entry.enabled)
        label.enabled.onClick = function(widget)
          entry.enabled = not entry.enabled
          label.enabled:setChecked(entry.enabled)
        end
        label.remove.onClick = function(widget)
          table.removevalue(storage[MousePanelName].itemTable, entry)
          reindexTable(storage[MousePanelName].itemTable)
          label:destroy()
        end
        label:setText(entry.origin .. entry.sign .. entry.value .. ":" .. entry.item)
      end
    end
  end
  refreshItems()

  MouseWindow.spells.MoveUp.onClick = function(widget)
    local input = MouseWindow.spells.spellList:getFocusedChild()
    if not input then return end
    local index = MouseWindow.spells.spellList:getChildIndex(input)
    if index < 2 then return end

    local move
    if storage[MousePanelName].spellTable and #storage[MousePanelName].spellTable > 0 then
      for _, entry in pairs(storage[MousePanelName].spellTable) do
        if entry.index == index -1 then
          move = entry
        end
        if entry.index == index then
          move.index = index
          entry.index = index -1
        end
      end
    end
    table.sort(storage[MousePanelName].spellTable, function(a,b) return a.index < b.index end)

    MouseWindow.spells.spellList:moveChildToIndex(input, index - 1)
    MouseWindow.spells.spellList:ensureChildVisible(input)
  end

  MouseWindow.spells.MoveDown.onClick = function(widget)
    local input = MouseWindow.spells.spellList:getFocusedChild()
    if not input then return end
    local index = MouseWindow.spells.spellList:getChildIndex(input)
    if index >= MouseWindow.spells.spellList:getChildCount() then return end

    local move
    local move2
    if storage[MousePanelName].spellTable and #storage[MousePanelName].spellTable > 0 then
      for _, entry in pairs(storage[MousePanelName].spellTable) do
        if entry.index == index +1 then
          move = entry
        end
        if entry.index == index then
          move2 = entry
        end
      end
      if move and move2 then
        move.index = index
        move2.index = index + 1
      end
    end
    table.sort(storage[MousePanelName].spellTable, function(a,b) return a.index < b.index end)

    MouseWindow.spells.spellList:moveChildToIndex(input, index + 1)
    MouseWindow.spells.spellList:ensureChildVisible(input)
  end

  MouseWindow.items.MoveUp.onClick = function(widget)
    local input = MouseWindow.items.itemList:getFocusedChild()
    if not input then return end
    local index = MouseWindow.items.itemList:getChildIndex(input)
    if index < 2 then return end

    local move
    if storage[MousePanelName].itemTable and #storage[MousePanelName].itemTable > 0 then
      for _, entry in pairs(storage[MousePanelName].itemTable) do
        if entry.index == index -1 then
          move = entry
        end
        if entry.index == index then
          move.index = index
          entry.index = index - 1
        end
      end
    end
    table.sort(storage[MousePanelName].itemTable, function(a,b) return a.index < b.index end)

    MouseWindow.items.itemList:moveChildToIndex(input, index - 1)
    MouseWindow.items.itemList:ensureChildVisible(input)
  end

  MouseWindow.items.MoveDown.onClick = function(widget)
    local input = MouseWindow.items.itemList:getFocusedChild()
    if not input then return end
    local index = MouseWindow.items.itemList:getChildIndex(input)
    if index >= MouseWindow.items.itemList:getChildCount() then return end

    local move
    local move2
    if storage[MousePanelName].itemTable and #storage[MousePanelName].itemTable > 0 then
      for _, entry in pairs(storage[MousePanelName].itemTable) do
        if entry.index == index +1 then
          move = entry
        end
        if entry.index == index then
          move2 = entry
        end
      end
      if move and move2 then
        move.index = index
        move2.index = index + 1
      end
    end
    table.sort(storage[MousePanelName].itemTable, function(a,b) return a.index < b.index end)

    MouseWindow.items.itemList:moveChildToIndex(input, index + 1)
    MouseWindow.items.itemList:ensureChildVisible(input)
  end

  MouseWindow.spells.addSpell.onClick = function(widget)
 
    local spellFormula = MouseWindow.spells.spellFormula:getText():trim()
    local spellSource = MouseWindow.spells.spellSource:getCurrentOption().text
    local source

    if spellSource == "Scroll Up" then
      source = "Scroll Up"
    elseif spellSource == "Scroll Down" then
      source = "Scroll Down"
    elseif spellSource == "MButton1" then
      source = "Mouse1"
    else
      source = "Mouse2"
    end

    if spellFormula:len() > 0 then
      table.insert(storage[MousePanelName].spellTable,  {index = #storage[MousePanelName].spellTable+1, spell = spellFormula, origin = source, enabled = true})
      MouseWindow.spells.spellFormula:setText('')
    end
    refreshSpells()
  end

  MouseWindow.items.addItem.onClick = function(widget)
 
    local id = MouseWindow.items.itemId:getItemId()
    local trigger = tonumber(MouseWindow.items.itemValue:getText())
    local src = MouseWindow.items.itemSource:getCurrentOption().text
    local eq = MouseWindow.items.itemCondition:getCurrentOption().text
    local source
    local equasion

    if not trigger then
      warn("MouseBot: incorrect trigger value!")
      MouseWindow.items.itemId:setItemId(0)
      MouseWindow.items.itemValue:setText('')
      return
    end

    if spellSource == "Scroll Up" then
      source = "Scroll Up"
    elseif spellSource == "Scroll Down" then
      source = "Scroll Down"
    elseif spellSource == "MButton1" then
      source = "Mouse1"
    elseif spellSource == "MButton2" then
      source = "Mouse2"
    end
  

    if id > 100 then
      table.insert(storage[MousePanelName].itemTable, {index = #storage[MousePanelName].itemTable+1,item = id, sign = equasion, origin = source, value = trigger, enabled = true})
      refreshItems()
      MouseWindow.items.itemId:setItemId(0)
      MouseWindow.items.itemValue:setText('')
    end
  end

  MouseWindow.closeButton.onClick = function(widget)
    MouseWindow:hide()
  end
end

local gamePanel = modules.game_interface.gameMapPanel
  gamePanel.onMouseWheel = function(widget, mousePos, scroll)
    if storage[MousePanelName].enabled then
    for _, entry in pairs(storage[MousePanelName].spellTable) do
      if entry.enabled then
        if entry.origin == "Scroll Up" then
            if scroll == 1 then
              say(entry.spell)
            end
          end
        if entry.origin == "Scroll Down" then 
          if scroll == 2 then
              say(entry.spell)
            end
          end
        end
      end
    end
  end

--spells2

macro(1, function()

if not storage[MousePanelName].enabled then return end
  for _, entry in pairs(storage[MousePanelName].spellTable) do
    if entry.enabled then
      if entry.origin == "Mouse1" then
        if g_mouse.isPressed(7) then
          say(entry.spell)
        end
      end
        if entry.origin == "Mouse2" then
          if g_mouse.isPressed(8) then
            say(entry.spell)
          end    
        end
end
end
end)

-- items
macro(500, function()
  if TargetBot.isOff() then storage.lootStatus = "" end
  if not storage[MousePanelName].enabled or storage.isUsing or #storage[MousePanelName].itemTable == 0 then return end

  if storage.lootStatus:len() > 0 then
    delay(500)
  end
  for _, entry in pairs(storage[MousePanelName].itemTable) do
    local item = findItem(entry.item)
    if item and entry.enabled then
      if entry.origin == "HP%" then
        if entry.sign == "=" and hppercent() == entry.value then
          useWith(entry.item, player)
          return
        elseif entry.sign == ">" and hppercent() >= entry.value then
          useWith(entry.item, player)
          return
        elseif entry.sign == "<" and hppercent() <= entry.value then
          useWith(entry.item, player)
          return
        end
      elseif entry.origin == "HP" then
        if entry.sign == "=" and hp() == tonumberentry.value then
          useWith(entry.item, player)
          return
        elseif entry.sign == ">" and hp() >= entry.value then
          useWith(entry.item, player)
          return
        elseif entry.sign == "<" and hp() <= entry.value then
          useWith(entry.item, player)
          return
        end
      elseif entry.origin == "MP%" then
        if entry.sign == "=" and manapercent() == entry.value then
          useWith(entry.item, player)
          return
        elseif entry.sign == ">" and manapercent() >= entry.value then
          useWith(entry.item, player)
          return
        elseif entry.sign == "<" and manapercent() <= entry.value then
          useWith(entry.item, player)
          return
        end
      elseif entry.origin == "MP" then
        if entry.sign == "=" and mana() == entry.value then
          useWith(entry.item, player)
          return
        elseif entry.sign == ">" and mana() >= entry.value then
          useWith(entry.item, player)
          return
        elseif entry.sign == "<" and mana() <= entry.value then
          useWith(entry.item, player)
          return
        end   
      end
    end
  end
end)

-- SCRIPTS 2 --

setDefaultTab("Main")
g_ui.loadUIFromString([[
scripts2ScrollBar < Panel
  height: 28
  margin-top: 3


  UIWidget
    id: text
    anchors.left: parent.left
    anchors.right: parent.right
    anchors.top: parent.top
    text-align: center
    
  HorizontalScrollBar
    id: scroll
    anchors.left: parent.left
    anchors.right: parent.right
    anchors.top: prev.bottom
    margin-top: 3
    minimum: 0
    maximum: 10
    step: 1

scripts2TextEdit < Panel
  height: 40
  margin-top: 7

  UIWidget
    id: text
    anchors.left: parent.left
    anchors.right: parent.right
    anchors.top: parent.top
    text-align: center
    
  TextEdit
    id: textEdit
    anchors.left: parent.left
    anchors.right: parent.right
    anchors.top: prev.bottom
    margin-top: 5
    minimum: 0
    maximum: 10
    step: 1
    text-align: center


scripts2Item < Panel
  height: 34
  margin-top: 7
  margin-left: 25
  margin-right: 25


  UIWidget
    id: text
    anchors.left: parent.left
    anchors.verticalCenter: next.verticalCenter

  BotItem
    id: item
    anchors.top: parent.top
    anchors.right: parent.right



scripts2CheckBox < BotSwitch
  height: 20
  margin-top: 7

scripts2Window < MainWindow
  !text: tr('Scripts [2]')
  font: verdana-11px-rounded
  color: green
  size: 460 360
  padding: 25
  @onEscape: self:hide()



  Label
    anchors.left: parent.left
    anchors.right: parent.horizontalCenter
    anchors.top: parent.top
    text-align: center
    text: < PvP >
    font: verdana-11px-rounded
    color: pink

  Label
    anchors.left: parent.horizontalCenter
    anchors.right: parent.right
    anchors.top: parent.top
    text-align: center
    text: < Utilidades >
    font: verdana-11px-rounded
    color: pink



  VerticalScrollBar
    id: contentScroll
    anchors.top: prev.bottom
    margin-top: 3
    anchors.right: parent.right
    anchors.bottom: separator.top
    step: 28
    pixels-scroll: true
    margin-right: 190
    margin-top: 5
    margin-bottom: 5

  ScrollablePanel
    id: content
    anchors.top: prev.top
    anchors.left: parent.left
    anchors.right: parent.right
    anchors.bottom: separator.top
    vertical-scrollbar: contentScroll
    margin-bottom: 10

      
    Panel
      id: left
      anchors.top: parent.top
      anchors.left: parent.left
      anchors.right: parent.horizontalCenter
      margin-top: 5
      margin-left: 10
      margin-right: 10
      layout:
        type: verticalBox
        fit-children: true
    focusable: false


    Panel
      id: right
      anchors.top: parent.top
      anchors.left: parent.horizontalCenter
      anchors.right: parent.right
      margin-top: 5
      margin-left: 30
      margin-right: 13
      layout:
        type: verticalBox
        fit-children: true
      focusable: false




  HorizontalSeparator
    id: separator
    height: 16
    anchors.right: parent.right
    anchors.left: parent.left
    anchors.bottom: closeButton.top
    margin-bottom: 8

  ResizeBorder
    id: bottomResizeBorder
    anchors.fill: separator
    height: 3
    minimum: 260
    maximum: 600
    margin-left: 3
    margin-right: 3
    background: #ffffff88   

  Label
    id: stopp
    anchors.right: parent.right
    anchors.bottom: parent.bottom
    text-align: center
    margin-top: 16
    margin-right: 175
    font: verdana-11px-rounded
    text: @customized
    color: #00FFFF
    !tooltip: tr('Use fones de ouvido para ter uma experiencia melhor.')  

  Button
    id: closeButton
    !text: tr('Fechar')
    color: yellow
    font: verdana-11px-rounded
    anchors.right: parent.right
    anchors.bottom: parent.bottom
    size: 45 21
    margin-right: 5
]])




local panelName = "scripts2"
local ui = setupUI([[
Panel

  height: 20


  ]], parent)
  ui:setId(PanelName)

if not storage[panelName] then
  storage[panelName] = {
}
end

local settings = storage[panelName]


scripts2Window = UI.createWindow('scripts2Window', rootWidget)
scripts2Window:hide()

scripts2Window.closeButton.onClick = function(widget)
  scripts2Window:hide()
end



scripts2Window.onGeometryChange = function(widget, old, new)
  if old.height == 0 then return end
  
  settings.height = new.height
end

scripts2Window:setHeight(settings.height or 360)


local rightPanel = scripts2Window.content.right
local leftPanel = scripts2Window.content.left




modules.game_interface.addMenuHook("category", "Scripts [2]",
  function()
          scripts2Window:show()
  end,
  function(menuPosition, lookThing, useThing, creatureThing)
    if creatureThing and creatureThing == player then
      return true
    end
    return false
  end
)



local addCheckBox = function(id, title, defaultValue, dest, tooltip)
  local widget = UI.createWidget('scripts2CheckBox', dest)
  widget.onClick = function()
    widget:setOn(not widget:isOn())
    settings[id] = widget:isOn()
    if id == "checkPlayer" then
      local label = rootWidget.newHealer.targetSettings.vocations.title
      if not widget:isOn() then
        label:setColor("#d9321f")
        label:setTooltip("! WARNING ! \nTurn on check players in scripts2 to use this feature!")
      else
          label:setColor("#dfdfdf")
          label:setTooltip("")
      end
    end
  end
  widget:setText(title)
  widget:setTooltip(tooltip)
  if settings[id] == nil then
    widget:setOn(defaultValue)
  else
    widget:setOn(settings[id])
  end
  settings[id] = widget:isOn()
end

local addItem = function(id, title, defaultItem, dest, tooltip)
  local widget = UI.createWidget('scripts2Item', dest)
  widget.text:setText(title)
  widget.text:setColor("green")
  widget.text:setFont("verdana-11px-rounded")
  widget.text:setTooltip(tooltip)
  widget.item:setTooltip(tooltip)
  widget.item:setItemId(settings[id] or defaultItem)
  widget.item.onItemChange = function(widget)
    settings[id] = widget:getItemId()
  end
  settings[id] = settings[id] or defaultItem
end

local addTextEdit = function(id, title, defaultValue, dest, tooltip)
  local widget = UI.createWidget('scripts2TextEdit', dest)
  widget.text:setText(title)
  widget.text:setColor("green")
  widget.text:setFont("verdana-11px-rounded")
  widget.textEdit:setText(settings[id] or defaultValue or "")
  widget.text:setTooltip(tooltip)
  widget.textEdit.onTextChange = function(widget,text)
    settings[id] = text
  end
  settings[id] = settings[id] or defaultValue or ""
end

local addScrollBar = function(id, title, min, max, defaultValue, dest, tooltip)
  local widget = UI.createWidget('scripts2ScrollBar', dest)
  widget.text:setTooltip(tooltip)
  widget.text:setColor("green")
  widget.text:setFont("verdana-11px-rounded")
  widget.scroll.onValueChange = function(scroll, value)
    widget.text:setText(title .. ": " .. value)
    if value == 0 then
      value = 1
    end
    settings[id] = value
  end
  widget.scroll:setRange(min, max)
  widget.scroll:setTooltip(tooltip)
  if max-min > 1000 then
    widget.scroll:setStep(100)
  elseif max-min > 100 then
    widget.scroll:setStep(10)
  end
  widget.scroll:setValue(settings[id] or defaultValue)
  widget.scroll.onValueChange(widget.scroll, widget.scroll:getValue())
end





addItem("kunai", "Kunai: ", 0, leftPanel, "Arraste ou coloque o id da kunai para usar o dash kunai")


addCheckBox("dashkunai", "Dash Kunai", false, leftPanel, "Use a kunai enquanto voce corre")
if true then

function funcSuperDashUseWith(parent)
 if not parent then
    parent = panel
  end

  onKeyPress(function(keys)

    itemUseId = (settings.kunai)
    dashSQMs = 8
    dashSQMs2 = 6

    if not settings.dashkunai then
      return
    end
    consoleModule = modules.game_console
    if (keys == "W" and not consoleModule:isChatEnabled()) or keys == "Up" then
        schedule(50,function()
          moveToTile = g_map.getTile({x = posx(), y = posy()-dashSQMs2, z = posz()})
          if moveToTile then
           g_game.useInventoryItemWith(itemUseId, moveToTile:getTopThing())
          end
        end)
    elseif (keys == "A" and not consoleModule:isChatEnabled()) or keys == "Left" then
        schedule(50,function()
          moveToTile = g_map.getTile({x = posx()-dashSQMs, y = posy(), z = posz()})
          if moveToTile then
            g_game.useInventoryItemWith(itemUseId, moveToTile:getTopThing())
          end
        end)
    elseif (keys == "S" and not consoleModule:isChatEnabled()) or keys == "Down" then
        schedule(50,function()
          moveToTile = g_map.getTile({x = posx(), y = posy()+dashSQMs2, z = posz()})
          if moveToTile then
              g_game.useInventoryItemWith(itemUseId, moveToTile:getTopThing())
          end
        end)
    elseif (keys == "D" and not consoleModule:isChatEnabled()) or keys == "Right" then
        schedule(50,function()
          moveToTile = g_map.getTile({x = posx()+dashSQMs, y = posy(), z = posz()})
          if moveToTile then
              g_game.useInventoryItemWith(itemUseId, moveToTile:getTopThing())
          end
        end)
    end

  end)
end
funcSuperDashUseWith() local usingWASD = modules.game_walking.wsadWalking
end

UI.Separator(leftPanel)

UI.TextEdit(storage.stack or "Nome da magia", function(widget, text)   
  storage.stack = text
end,leftPanel)

addScrollBar("stackk", "Distancia do stack", 0, 10, 10, leftPanel, "defina a distancia do mostro para usar a magia.")

addCheckBox("stack", "Stack", false, leftPanel, "Ataca o monstro mais distante conforme sua direção, atalho CapsLock + wasd")
if true then
end

local Stack = {};

Stack.northPattern = [[
    11111
    11111
    11111
    11111
    11111
    11111
    11111
    11111
    00000
    00000
    00000
    00000
    00000
    00000
    00000
    00000
    00000
]];

Stack.southPattern = [[
    00000
    00000
    00000
    00000
    00000
    00000
    00000
    00000
    00000
    11111
    11111
    11111
    11111
    11111
    11111
    11111
    11111
]];

Stack.westPattern = [[
    1111111110000000000
    1111111110000000000
    1111111110000000000
    1111111110000000000
    1111111110000000000
]];

Stack.eastPattern = [[
    0000000000111111111
    0000000000111111111
    0000000000111111111
    0000000000111111111
    0000000000111111111
]];

local spell = (storage.stack)
local maxDistance = (settings.stackk)


macro(1, function() 
    local furthestMonster = nil;
    local pattern = nil;
    if settings.stack and (modules.corelib.g_keyboard.areKeysPressed("CapsLock+W")) then
        pattern = Stack.northPattern;
    elseif settings.stack and (modules.corelib.g_keyboard.areKeysPressed("CapsLock+S")) then
        pattern = Stack.southPattern;
    elseif settings.stack and (modules.corelib.g_keyboard.areKeysPressed("CapsLock+A")) then
        pattern = Stack.westPattern;
    elseif settings.stack and (modules.corelib.g_keyboard.areKeysPressed("CapsLock+D")) then
        pattern = Stack.eastPattern;
    end

    if (not pattern) then return; end

    local playerPos = pos();
    for _, creature in pairs(getSpectators(playerPos, pattern)) do
        if (not creature:isNpc() and creature:canShoot() and not creature:isPlayer()) then
            local monsterDistance = getDistanceBetween(playerPos, creature:getPosition())
            if (monsterDistance <= maxDistance and
                (
                    furthestMonster == nil or
                    monsterDistance > getDistanceBetween(playerPos, furthestMonster:getPosition())
                )
            ) then
                furthestMonster = creature;
            end
        end
    end

    if (not furthestMonster) then return; end


    g_game.stop();
    g_game.attack(furthestMonster);

    say(spell);
    
    schedule(600, function()
        g_game.cancelAttack();
    end);
end);




addCheckBox("bugmap", "Bug-Map", false, leftPanel, "Desvia de obstaculos fora da pz")
if true then end

macro(1, function()
  if settings.bugmap and not isInPz() and not modules.corelib.g_keyboard.isCtrlPressed() then
  if modules.corelib.g_keyboard.isKeyPressed('Up') then
    checkPos(0, -6)
  elseif modules.corelib.g_keyboard.isKeyPressed('Right') then
    checkPos(6, 0)
  elseif modules.corelib.g_keyboard.isKeyPressed('Down') then
    checkPos(0, 6)
  elseif modules.corelib.g_keyboard.isKeyPressed('Left') then
    checkPos(-6, 0)
  end
end
end)







addCheckBox("jump", "Auto Jump ", false, leftPanel, "Usa Jump Up/Down na parede ao apertar 2 vez alguma tecla do WASD/Setas/Numpad.")
if true then

local walkDir
onKeyDown(function(keys)
  usingWASD = modules.game_walking.wsadWalking
  if usingWASD then
    if keys == "W" or keys == "A" or keys == "S" or keys == "D" then  -- WASD
      walkDir = keys
    end
  if usingWASD then
    if keys == "Numpad2" or keys == "Numpad4" or keys == "Numpad6" or keys == "Numpad8" then  -- Numpad
      walkDir = keys
    end
    if keys == "Up" or keys == "Right" or keys == "Down" or keys == "Left" then -- SETAS
      walkDir = keys
    end
  end
  end
end)

macro(2, function()
    if not settings.jump then
      return
    end
  local playerPos = pos()
  local levitateTile
  if walkDir == "W" or walkDir == "Up" or walkDir == "Numpad8" then -- north
    playerPos.y = playerPos.y - 1
    turn(0)
    levitateTile = g_map.getTile(playerPos)
  elseif walkDir == "D" or walkDir == "Right" or walkDir == "Numpad6" then -- east
    playerPos.x = playerPos.x + 1
    turn(1)
    levitateTile = g_map.getTile(playerPos)
  elseif walkDir == "S" or walkDir == "Down" or walkDir == "Numpad2" then -- south
    playerPos.y = playerPos.y + 1
    turn(2)
    levitateTile = g_map.getTile(playerPos)
  elseif walkDir == "A" or walkDir == "Left" or walkDir == "Numpad4" then -- west
    playerPos.x = playerPos.x - 1
    turn(3)
    levitateTile = g_map.getTile(playerPos)
end



  if levitateTile and not levitateTile:isWalkable() then
    if levitateTile:getGround() then
      say('Jump up')
      walkDir = nil
    else
      say('Jump down')
      walkDir = nil
    end
  end
  walkDir = nil
end)
end





addCheckBox("jumpseta", "Auto Jump Marcado", false, leftPanel, "Usa Jump Up/Down na posicao setada, usando kunai e jump, configure as teclas no painel de configuracao.")
if true then
end





exhaustPot = 0
if type(storage[player:getName()]) ~= 'table' or #storage[player:getName()] == 0 then
  storage[player:getName()] = {}
  storage[player:getName()][1] = {texto = 'Stack', magia = 'Shunshin', totalAtivo = 0, totalExhaust = 3000, exhaustTime = 0, activeTime = 0}
end

Exhausted = function(var) return type(var) == 'number' and var >= now end

local Keys = modules.corelib.g_keyboard.isKeyPressed

function getNearTiles(pos)
    if type(pos) ~= "table" then pos = pos:getPosition() end

    local tiles = {}
    local dirs = {
        {-1, 1}, {0, 1}, {1, 1}, {-1, 0}, {1, 0}, {-1, -1}, {0, -1}, {1, -1}
    }
    for i = 1, #dirs do
        local tile = g_map.getTile({
            x = pos.x - dirs[i][1],
            y = pos.y - dirs[i][2],
            z = pos.z
        })
        if tile then table.insert(tiles, tile) end
    end

    return tiles
end



getItem = function(tile, id)
  for index, value in ipairs(tile:getItems()) do
    if value:getId() == id then
      return false
    end
  end
  return true
end


Jump = {}

Jump.tecla = (storage.jumpuplocal)

Jump.saveUp = (storage.jumpuplocal1)

Jump.saveDown = (storage.jumpuplocal2)

Jump.remove = (storage.jumpuplocal3)



Jump.upOrdown = function()
    if Keys(Jump.saveUp) then
        return 1
    elseif Keys(Jump.saveDown) then
        return 2
    end
    return false
end

Jump.comparePos = function(p1, p2)
  return p1.x == p2.x and p1.y == p2.y and p1.z == p2.z
end

Jump.findPos = function(pos)
    for x, v in ipairs(storage.jumps) do
        if Jump.comparePos(pos, v) then
            return x
        end
    end
  return false
end

Jump.removeIt = function(position)
    for x, v in ipairs(storage.jumps) do
        if Jump.comparePos(position, v) then
            info('Removed: ' .. Jump.postostring(position))
      if Jump.comparePos(position, Jump.Pos) then
        if g_map.getTile(Jump.Pos) then
          g_map.getTile(Jump.Pos):setText('')
        end
        Jump.Pos = {x = 0, y = 0, z = 0}
      end
            return table.remove(storage.jumps, x)
        end
    end
end


Jump.preciseDistance = function(pos1, pos2)
    return math.abs(pos1.x - pos2.x) + math.abs(pos1.y - pos2.y)
end

if type(storage.jumps) ~= 'table' then
  storage.jumps = {}
end

Jump.postostring = function(pos)
    return pos.x .. ',' .. pos.y .. ',' .. pos.z
end

function Jump.actualDirection()
    local dir = player:getDirection()
    if dir > 3 then
        if dir < 6 then
            return 1
        else
            return 3
        end
    else
        return dir
    end
end

Jump.convertPos = function(position)
    local pos = pos()
    pos.x = position.x
    pos.y = position.y
    pos.z = position.z
    return pos
end

Jump.Pos = {x = 0, y = 0, z = 0}

macro(100, function()
      if not settings.jumpseta then
      return
    end
    if Keys(Jump.remove) then
        return Jump.removeIt(player:getPosition())
    end
    checarSave = Jump.upOrdown()
    if checarSave and not Jump.findPos(pos()) then
    save = 'Jump down'
        if checarSave == 1 then
            save = 'Jump up'
    end
        info('Saved: ' .. Jump.postostring(pos()) .. ' ' .. save)
        table.insert(storage.jumps, {jumpTo = save, direction = Jump.actualDirection(), x = pos().x, y = pos().y, z = pos().z})
    end
    if #storage.jumps > 0 and Jump.lastPos ~= Jump.postostring(pos()) then
        for c, k in ipairs(storage.jumps) do
            local kPos = Jump.convertPos(k)
            if kPos.z == pos().z then
                if (Jump.preciseDistance(pos(), kPos) < Jump.preciseDistance(pos(), Jump.Pos) or pos().z ~= Jump.Pos.z) then
                    if findPath(pos(), kPos, 100, {ignoreNonPathable = false, ignoreStairs = true, ignoreCreatures = false}) then
                        Jump.actual = k
                        if g_map.getTile(Jump.Pos) then
                            g_map.getTile(Jump.Pos):setText('')
                        end
                        Jump.Pos = kPos    
                    end
                end
            end
        end
    Jump.lastPos = Jump.postostring(pos())
    end
    Jump.tile = g_map.getTile(Jump.Pos)
    if Jump.tile then
        local distance = getDistanceBetween(Jump.Pos, pos())
        if Keys(Jump.tecla) then
            Jump.tile:setText(Jump.actual.jumpTo, 'green')
            if distance > 1 then
        for index, value in ipairs(getNearTiles(Jump.Pos)) do
          if getItem(value, 1771) then
            if value:canShoot() and (value:isWalkable() or value:getTopThing():getName():len() > 0) and value:isPathable() then
              if not Exhausted(storage[player:getName()][1].exhaustTime) then
                useWith(settings.kunai, value:getTopThing())
                g_game.stop()
              end
            end
          end
        end
        if not (Jump.waitToReach and Jump.waitToReach >= now) and distance > 3 then
          player:autoWalk(Jump.Pos)
          Jump.waitToReach = now + 750
        else
          g_game.use(Jump.tile:getTopUseThing())
        end
            elseif distance == 1 then
                if (not Jump.waitToWalk or Jump.waitToWalk < now) and not player:isServerWalking() then
                    autoWalk(Jump.Pos, 1)
                    Jump.waitToWalk = now + 500
                end
            elseif Jump.actualDirection() ~= Jump.actual.direction then
                g_game.turn(Jump.actual.direction)
            else
                say(Jump.actual.jumpTo)
            end
        else
            Jump.tile:setText(Jump.actual.jumpTo, 'red')
        end
    end
end)


macro(1, "Atacar Monstros", function()
  if not isInPz() then 
    if not g_game.getAttackingCreature() then 
      for _, spec in ipairs(getSpectators()) do
        if spec:isMonster() then 
          g_game.attack(spec)
        end
      end
    end
  end
end, rightPanel)

addCheckBox("monstrovida", "Monstros % de vida", false, leftPanel, "Mostra a porcentagem de vida dos monstros.")
if true then

local showhp = macro(200, function() end)


onCreatureHealthPercentChange(function(creature, healthPercent)
if settings.monstrovida then
    if showhp:isOff() then  return end
    if creature:isMonster() or creature:isPlayer() and creature:getPosition() and pos() then
        if creature:getPosition() then
            creature:setText(healthPercent .. "%")
        else
            creature:clearText()

      end
    end
  end
end)

end


addCheckBox("levelbar", "SKILLS BAR", false, leftPanel, "Ative para ativar sua level bar abaixo do seu char.")
if true then end

local uiskills = setupUI([[
Panel
  height:2000
  width: 2000

  ProgressBar
    id: stamPercent
    background-color: white
    text: 100%
    width: 160
    margin-right: 5
  Label
    id: stam
    font: verdana-11px-rounded
    text-horizontal-auto-resize: true
    color: #5d00ff
    text-align: center

  ProgressBar
    id: percenter
    background-color: white
    text: 100%
    width: 160
    margin-right: 5
  Label
    id: Level
    font: verdana-11px-rounded
    text-horizontal-auto-resize: true
    color: #5d00ff
    text-align: center

  ProgressBar
    id: MLPercent
    background-color: white
    text: 100%
    width: 160
    margin-right: 5
  Label
    id: ML
    font: verdana-11px-rounded
    text-horizontal-auto-resize: true
    color: #5d00ff
    text-align: center

    ]], modules.game_interface.getMapPanel())

local doFormatTime = function(v)
    local hours = string.format("%02.f", math.floor(v / 3600))
    local mins = string.format("%02.f", math.floor(v / 60 - (hours * 60)))
    local seconds = string.format("%02.f", math.floor(math.mod(v, 60)))
    return hours .. ":" .. mins .. ":" .. seconds
end

uiskills.stamPercent:setBackgroundColor("yellow")
g_ui.getRootWidget():recursiveGetChildById("stam"):setPosition({x = 10, y = 150})
g_ui.getRootWidget():recursiveGetChildById("stamPercent"):setPosition({x = 10, y = 165})
uiskills.percenter:setBackgroundColor("red")
g_ui.getRootWidget():recursiveGetChildById("Level"):setPosition({x = 10, y = 50})
g_ui.getRootWidget():recursiveGetChildById("percenter"):setPosition({x = 10, y = 65})
uiskills.MLPercent:setBackgroundColor("orange")
g_ui.getRootWidget():recursiveGetChildById("ML"):setPosition({x = 10, y = 100})
g_ui.getRootWidget():recursiveGetChildById("MLPercent"):setPosition({x = 10, y = 115})

macro(1, function()
  if settings.levelbar then 
    local MLPC = player:getMagicLevelPercent()
    uiskills.MLPercent:setText(MLPC.."%")
    uiskills.MLPercent:setPercent(MLPC)
    uiskills.ML:setText("ML: ".. player:getMagicLevel())
    uiskills.MLPercent:setFont("terminus-14px-bold")
    local LevelPC = player:getLevelPercent()
    uiskills.percenter:setText(LevelPC.."%")
    uiskills.percenter:setPercent(LevelPC)
    uiskills.Level:setText("LEVEL: ".. level())
    uiskills.percenter:setFont("terminus-14px-bold")
    uiskills.stam:setText("Stamina: ".. doFormatTime(player:getStamina()))
    uiskills.stamPercent:setText(math.floor(100 * player:getStamina() / (42 * 60)).."%")
    uiskills.stamPercent:setPercent(math.floor(100 * player:getStamina() / (42 * 60)))
    uiskills.stamPercent:setFont("terminus-14px-bold")
    uiskills:show()
  else
    uiskills:hide()
end
end)

local Keys = modules.corelib.g_keyboard.isKeyPressed



function getNearTiles(pos)
    if type(pos) ~= "table" then pos = pos:getPosition() end

    local tiles = {}
    local dirs = {
        {-1, 1}, {0, 1}, {1, 1}, {-1, 0}, {1, 0}, {-1, -1}, {0, -1}, {1, -1}
    }
    for i = 1, #dirs do
        local tile = g_map.getTile({
            x = pos.x - dirs[i][1],
            y = pos.y - dirs[i][2],
            z = pos.z
        })
        if tile then table.insert(tiles, tile) end
    end

    return tiles
end


Stairs = {}


Stairs.Exclude = {}
Stairs.Click = {7047, 5102, 5111, 6207, 1948, 435, 7771, 5542, 8657, 6264, 1646, 1648, 1678, 5291, 1680, 6905, 6262, 1664, 13296, 1067, 13861, 11931, 1949, 6896, 6205}


Stairs.postostring = function(pos)
    return pos.x .. ',' .. pos.y .. ',' .. pos.z
end

function Stairs.accurateDistance(c)
    if type(c) == 'userdata' then
        c = c:getPosition()
    end
    return math.abs(pos().x-c.x) + math.abs(pos().y-c.y)
end

Stairs.Check = {}

Stairs.checkTile = function(tile)
    if not tile then
        return false
  end
  
  local pos = Stairs.postostring(tile:getPosition())
  
    if Stairs.Check[pos] ~= nil then
        return Stairs.Check[pos]
  end
  
    if not tile:getTopUseThing() then
    Stairs.Check[pos] = false
        return false
    end
  
    for _, x in ipairs(tile:getItems()) do
        if table.find(Stairs.Click, x:getId()) then
            Stairs.Check[pos] = true
      return true
        elseif table.find(Stairs.Exclude, x:getId()) then
      Stairs.Check[pos] = false
      return false
    end
    end
  
    local cor = g_map.getMinimapColor(tile:getPosition())
    if cor >= 210 and cor <= 213 and not tile:isPathable() and tile:isWalkable() then
    Stairs.Check[pos] = true
        return true
  else
    Stairs.Check[pos] = false
        return false
    end
end


Stairs.checkAll = function()
  local tiles = {}
  for _, tile in ipairs(g_map.getTiles(posz())) do
    if Stairs.checkTile(tile) then
      table.insert(tiles, tile)
    end
  end
  if #tiles == 0 then return end
    table.sort(tiles, function(a, b)
        return Stairs.accurateDistance(a:getPosition()) < Stairs.accurateDistance(b:getPosition())
    end)
    for y, z in ipairs(tiles) do
        if findPath(z:getPosition(), pos(), 100, { ignoreCreatures = false, ignoreNonWalkable = false, ignoreNonPathable = false}) then
            return z
        end
    end
  return false
end


onPlayerPositionChange(function(newPos, oldPos)
  lastWalk = nil
end)

getItem = function(tile, id)
  for index, value in ipairs(tile:getItems()) do
    if value:getId() == id then
      return false
    end
  end
  return true
end

addCheckBox("escadd", "Auto Escada", false, leftPanel, "Suba e desca escadas precionando botao de atalho.")
if true then
end
macro(1, function()
  if modules.game_console:isChatEnabled() then return end
    if Stairs.postostring(player:getPosition()) == Stairs.lastPosition then
        if Keys(storage.escadaid) and Stairs.See and settings.escadd then
      if lastWalk and lastWalk >= now then return end
      local pos = Stairs.See:getPosition()
      Stairs.distance = getDistanceBetween(player:getPosition(), pos)
            Stairs.See:setText('Escada\n' .. storage.escadaid, 'green')
            if Stairs.See:isWalkable() and not Stairs.See:isPathable() and not player:isServerWalking() and (not lastWalk or lastWalk < now) and autoWalk(pos, 1) then lastWalk = now + 500 return end
      if Stairs.distance > 1 then
        for index, value in ipairs(getNearTiles(pos)) do
          if getItem(value, 1771) then
            if value:canShoot() and (value:isWalkable() or value:getTopThing():getName():len() > 0) and value:isPathable() then
              if not Exhausted(storage[player:getName()][1].exhaustTime) then
                useWith(settings.kunai, value:getTopThing())
              end
            end
          end
        end
      end
      if (Stairs.tryWalk and Stairs.tryWalk >= now) or Stairs.distance <= 3 then
        g_game.use(Stairs.See:getTopUseThing())
      else
        player:autoWalk(pos)
        Stairs.tryWalk = now + 1000
      end
        elseif Stairs.See and Stairs.See:getTopUseThing() and settings.escadd then
            Stairs.See:setText('Escada\n' .. storage.escadaid, 'red')
    end
        return
    end
    if Stairs.See and Stairs.See:getTopUseThing() then
        Stairs.See:setText('')
    end
    Stairs.See = Stairs.checkAll()
    Stairs.lastPosition = Stairs.postostring(player:getPosition())
end)


cor = UI.Label("Botao de atalho escada:", leftPanel)
cor:setColor("green")
cor:setFont("verdana-11px-rounded")
UI.Separator(leftPanel)

UI.TextEdit(storage.escadaid or "Space", function(widget, text)   
  storage.escadaid = text
end,leftPanel)

UI.Separator(leftPanel)
cor = UI.Label("Nome do Jogador:", leftPanel)
cor:setColor("green")
cor:setFont("verdana-11px-rounded")




followName = "autofollow"
if not storage[followName] then storage[followName] = { player = 'name'} end
local toFollowPos = {}
followTE = UI.TextEdit(storage[followName].player or "name", function(widget, newText)
    storage[followName].player = newText
end, leftPanel)

addCheckBox("followz", "Follow", false, leftPanel, "Da follow no jogador definido.")
if true then

addCheckBox("followr", "Follow Ataque", false, leftPanel, "Vai seguir o jogador e podendo atacar os monstros, tambem sobe escadas.")
if true then
end

local followChange = macro(200, function()
if settings.followz then
local followw= storage[followName].player 
    if g_game.isFollowing() then
        return
    end
    for _, followcreature in ipairs(g_map.getSpectators(pos(), false)) do
        if (followcreature:getName() == followw and getDistanceBetween(pos(), followcreature:getPosition()) <= 8) then
            g_game.follow(followcreature)
        end
    end
  end
end)

local followMacro = macro(20, function()
if settings.followr then
    local target = getCreatureByName(storage[followName].player)
    if target then
        local tpos = target:getPosition()
        toFollowPos[tpos.z] = tpos
    end
    if player:isWalking() then
        return
    end
    local p = toFollowPos[posz()]
    if not p then
        return
    end
    if autoWalk(p, 20, { ignoreNonPathable = true, precision = 1 }) then
    end
  end
end)

onPlayerPositionChange(function(newPos, oldPos)
  if followChange:isOff() then return end
  if (g_game.isFollowing()) then
    tfollow = g_game.getFollowingCreature()

    if tfollow then
      if tfollow:getName() ~= storage[followName].player then
        followTE:setText(tfollow:getName())
        storage[followName].player = tfollow:getName()
      end
    end
  end
end)
end

















addScrollBar("mana", "Mana", 0, 99, 1000, rightPanel, "% mana para treinar o magic level")

UI.Separator(rightPanel)

UI.TextEdit(storage.magiamana or "Nome da magia", function(widget, text)   
  storage.magiamana = text
end,rightPanel)

addCheckBox("manat", "Treinar Magic Level", false, rightPanel, "Vai usar a magia para treinar magic level")
macro(1, function()
    if settings.manat then
  if manapercent() > settings.mana then
say(storage.magiamana)
end
end
end)
UI.Separator(rightPanel)
UI.TextEdit(storage.chakrares or "Nome da magia", function(widget, text)   
  storage.chakrares = text
end,rightPanel)


macro(1, "Haste", function()
    if (not isInPz()) and not hasHaste() then say(storage.chakrares)
      end
    end, rightPanel)

addCheckBox("dance", "Dance", false, rightPanel, "Vai ficar girando, para evitar Kick")
macro(1, function()
if settings.dance then
    turn(math.random(0, 3))
end
end)

addCheckBox("treinar", "!Treinar", false, rightPanel, "Fala !treinar ao reconectar.")
if true then
end

macro(2000, function()
if settings.treinar then
    if treinar ~= true then
        treinar = true
        say("!treinar")
    end
end
end)



addCheckBox("colorir", "Alterar a cor dos nomes", false, rightPanel, "Altera a cor dos nomes de jogadores, guild, pk, pt,inimigo e jogadores que te atacam.")
if true then
macro(200, function ()
if settings.colorir then
for z, spec in ipairs(getSpectators()) do
  if spec:isPlayer() and spec:getSkull() == 3 then
            spec:setMarked("orange")
        
  end
end
for a, spec in ipairs(getSpectators()) do
  if spec:isPlayer() and spec:getEmblem() == 3 then
            spec:setMarked("pink")
  end
end
for a, spec in ipairs(getSpectators()) do
  if spec:isPlayer() and spec:getEmblem() == 2 then
            spec:setMarked("red")
  end
end
for a, spec in ipairs(getSpectators()) do
  if spec:isPlayer() and spec:getEmblem() == 1 then
            spec:setMarked("#00FFFF")
  end
end
for a, spec in ipairs(getSpectators()) do
  if spec:isPlayer() and spec:getShield() == 3 then
            spec:setMarked("blue")
  end
end
for a, spec in ipairs(getSpectators()) do
  if spec:isPlayer() and spec:getShield() == 4 then
            spec:setMarked("yellow")
  end
end

end
end)
end




addCheckBox("ptaceitar", "Aceitar PT", false, rightPanel, "Aceita convite de PT.")
if true then
end

macro(200, function()
if settings.ptaceitar then
for z, spec in ipairs(getSpectators()) do
  if spec:isPlayer() and spec:getShield() == 1 then
            g_game.partyJoin(spec:getId())
  end
end
end
end)



addCheckBox("ptinvite", "Auto Invite PT", false, rightPanel, "Invita jogadores que falarem PT no chat.")
if true then
end

onTalk(function(name, level, mode, text, channelId, pos)
if settings.ptinvite then
if name == player:getName() then return end
    if mode ~= 1 then  return end
    if string.find(text, "pt") and settings.ptinvite == true then
        local friend = getPlayerByName(name)
        g_game.partyInvite(friend:getId())
    end
  end
end)

UI.Label("", rightPanel)
local uitarget = setupUI([[
Panel
  height:2000
  width: 2000

  Label
    id: bossName
    text: None
    font: verdana-11px-rounded
    text-horizontal-auto-resize: true
    color: red
    text-align: center
  Label
    id: bossOutfit
    text: None
    font: verdana-11px-rounded
    text-horizontal-auto-resize: true
    color: red
  ProgressBar
    id: percent
    background-color: white
    text: 100%
    width: 160
    margin-right: 5

    ]], modules.game_interface.getMapPanel())

uitarget:hide()

macro(1, "Target [INFO]", function()
if not g_game.isAttacking() then
 uitarget:hide()

elseif g_game.isAttacking() then
  uitarget:show()
  --- get attacking creature name
   local mob = g_game.getAttackingCreature()
   uitarget.bossName:setText("Name: ".. mob:getName())

  --- get attacking creature health percent
   local monsterHP = mob:getHealthPercent()
   uitarget.percent:setText(monsterHP.."%")
   uitarget.percent:setPercent(monsterHP)
   uitarget.percent:setFont("terminus-14px-bold")

  --- get the outfit --
    uitarget.bossOutfit:setText("Outfit: ".. mob:getOutfit().type)
    uitarget.bossOutfit:setColor("yellow")

  if monsterHP == 100 then 
    uitarget.percent:setBackgroundColor("white")
   elseif monsterHP > 75 then
    uitarget.percent:setBackgroundColor("green")
   elseif monsterHP > 50 then
    uitarget.percent:setBackgroundColor("yellow")
   elseif monsterHP > 25 then
    uitarget.percent:setBackgroundColor("orange")
   elseif monsterHP > 1 then
    uitarget.percent:setBackgroundColor("red")
  end
 end
end, rightPanel)  


g_ui.getRootWidget():recursiveGetChildById("bossName"):setPosition({x = 850, y = 105})
g_ui.getRootWidget():recursiveGetChildById("percent"):setPosition({x = 850, y = 120})
g_ui.getRootWidget():recursiveGetChildById("bossOutfit"):setPosition({x = 895, y = 140})






addCheckBox("title", "Informacao na janela", false, rightPanel, "Personalize o nome da janela")
if true then
  macro(1, function()
    if settings.title then
      if hppercent() > 0 then
          g_window.setTitle(name() .. " - ".. "Level: " .. lvl() .. " % " .. player:getLevelPercent())
      else
          g_window.setTitle(name() .. " - MORTO")
      end
    else
      g_window.setTitle(name() .. " - ".. "Level: " .. lvl() .. " % " .. player:getLevelPercent())
    end
  end)
end

addCheckBox("separatePm", "Abrir pm", false, rightPanel, "Vai abrir as mensagens automatico e salvando se voce relogar")
if true then
  onTalk(function(name, level, mode, text, channelId, pos)
    if mode == 4 and settings.separatePm then
        local g_console = modules.game_console
        local privateTab = g_console.getTab(name)
        if privateTab == nil then
            privateTab = g_console.addTab(name, true)
            g_console.addPrivateText(g_console.applyMessagePrefixies(name, level, text), g_console.SpeakTypesSettings['private'], name, false, name)
        end
        return
    end
  end)
end









addCheckBox("autoOpenDoors", "Abrir portas", false, rightPanel, "Abra as portas ao tentar entrar nelas.")
if true then
  local doorsIds = { 5007, 8265, 1629, 1632, 5129, 6252, 6249, 7715, 7712, 7714, 
                     7719, 6256, 1669, 1672, 5125, 5115, 5124, 17701, 17710, 1642, 
                     6260, 5107, 4912, 6251, 5291, 1683, 1696, 1692, 5006, 2179, 5116, 
                     1632, 11705, 30772, 30774, 6248, 5735, 5732, 5120, 23873, 5736,
                     6264, 5122, 30049, 30042, 7727 }

  function checkForDoors(pos)
    local tile = g_map.getTile(pos)
    if tile then
      local useThing = tile:getTopUseThing()
      if useThing and table.find(doorsIds, useThing:getId()) then
        g_game.use(useThing)
      end
    end
  end

  onKeyPress(function(keys)
    local wsadWalking = modules.game_walking.wsadWalking
    if not settings.autoOpenDoors then return end
    local pos = player:getPosition()
    if keys == 'Up' or (wsadWalking and keys == 'W') then
      pos.y = pos.y - 1
    elseif keys == 'Down' or (wsadWalking and keys == 'S') then
      pos.y = pos.y + 1
    elseif keys == 'Left' or (wsadWalking and keys == 'A') then
      pos.x = pos.x - 1
    elseif keys == 'Right' or (wsadWalking and keys == 'D') then
      pos.x = pos.x + 1
    elseif wsadWalking and keys == "Q" then
      pos.y = pos.y - 1
      pos.x = pos.x - 1
    elseif wsadWalking and keys == "E" then
      pos.y = pos.y - 1
      pos.x = pos.x + 1
    elseif wsadWalking and keys == "Z" then
      pos.y = pos.y + 1
      pos.x = pos.x - 1
    elseif wsadWalking and keys == "C" then
      pos.y = pos.y + 1
      pos.x = pos.x + 1
    end
    checkForDoors(pos)
  end)
end




addCheckBox("moneyconverter", "Converter Dinheiro", false, rightPanel, "converte seu dinheiro.")
if true then
local moneyIds = {3031, 3035} -- gold coin, platinium coin
macro(1000, function()
if settings.moneyconverter then
  local containers = g_game.getContainers()
  for index, container in pairs(containers) do
    if not container.lootContainer then -- ignore monster containers
      for i, item in ipairs(container:getItems()) do
        if item:getCount() == 100 then
          for m, moneyId in ipairs(moneyIds) do
            if item:getId() == moneyId then
              return g_game.use(item)            
            end
          end
        end
      end
    end
  end
  end
end)
end





addCheckBox("bless", "Auto Bless", false, rightPanel, "Fala !bless ao entrar no game.")
if true then
  local blessed = false
  onTextMessage(function(mode,text) 
    if not settings.bless then return end
    
    text = text:lower()

    if text == "you already have all blessings." then
      blessed = true
    end
  end)
  if settings.bless then
    if player:getBlessings() == 0 then
      say("!bless")
      schedule(2000, function() 
          if g_game.getClientVersion() > 1000 then
            if not blessed and player:getBlessings() == 0 then
                warn("!! Blessings not bought !!")
            end
          end
      end)
    end
  end
end

addCheckBox("jamm", "Auto Jam", false, rightPanel, "Fala !jam quando nao haver nada no slot do amuleto.")
if true then
macro(1, function()
if settings.jamm then
  if not getNeck() then
      say('!jam')
  end
  end
end)
end


addCheckBox("reUse", "Manter mira Item", false, rightPanel, "Mantenha a mira depois de usar o item.")
if true then
  local excluded = {268, 237, 238, 23373, 266, 236, 239, 7643, 23375, 7642, 23374, 5908, 5942} 

  onUseWith(function(pos, itemId, target, subType)
    if settings.reUse and not table.find(excluded, itemId) then
      schedule(50, function()
        item = findItem(itemId)
        if item then
          modules.game_interface.startUseWith(item)
        end
      end)
    end
  end)
end



macro(1, 'Reta Ataque', function()
 if not g_game.isAttacking() then return end
 local tt = g_game.getAttackingCreature()
 local tx = tt:getPosition().x
 local ty = tt:getPosition().y
 local dir = player:getDirection()
 local tdx = math.abs(tx-pos().x)
 local tdy = math.abs(ty-pos().y)
 if (tdy >= 2 and tdx >= 2) or tdx > 7 or tdy > 7 then return end 
 if tdy >= tdx then
  if ty > pos().y then
   if dir ~= 2 then
    return turn(2)
   end
  else
   if dir ~= 0 then
    return turn(0)
   end
  end
 else
  if tx > pos().x then
   if dir ~= 1 then
    return turn(1)
   end
  else
   if dir ~= 3 then
    return turn(3)
   end
  end
 end
end, rightPanel)


addCheckBox("bagcheia", "Abrir proxima bag", false, rightPanel, "abre proxima bag quando atual estiver cheia.")
if true then
macro(1000, function()
if settings.bagcheia then
  local containers = getContainers()
  for i, container in pairs(containers) do
    if container:getItemsCount() == container:getCapacity() then
      for _, item in ipairs(container:getItems()) do
        if item:isContainer() then
          g_game.open(item, container)
        end
      end
    end
  end
end
end)
end

addCheckBox("juntaritens", "Juntar itens", false, rightPanel, "Junta os itens separados da bag.")
if true then
macro(1000, function()
if settings.juntaritens then
  local containers = g_game.getContainers()
  local toStack = {}
  for index, container in pairs(containers) do
    if not container.lootContainer then -- ignore monster containers
      for i, item in ipairs(container:getItems()) do
        if item:isStackable() and item:getCount() < 100 then
          local stackWith = toStack[item:getId()]
          if stackWith then
            g_game.move(item, stackWith[1], math.min(stackWith[2], item:getCount()))
            return
          end
          toStack[item:getId()] = {container:getSlotPosition(i - 1), 100 - item:getCount()}
        end
      end
    end
  end
end
end)
end

addScrollBar("hpmagiaalvo", "HP Alvo", 0, 100, 1000, leftPanel, "% de vida do alvo pra usar magia")


UI.Separator(leftPanel)

UI.TextEdit(storage.magiaalvo or "Nome da magia", function(widget, text)   
  storage.magiaalvo = text
end,leftPanel)

addCheckBox("hpmagia", "Magia hp alvo", false, leftPanel, "Usar magia baseado na vida do alvo.")
if true then
macro(200, function()
   if settings.hpmagia and g_game.isAttacking() and g_game.getAttackingCreature():isPlayer() and g_game.getAttackingCreature():getHealthPercent() < settings.hpmagiaalvo then
        say(storage.magiaalvo)  
    end 
end)
end




addCheckBox("lootlook", "Auto Loot Look", false, rightPanel, "Adiciona os itens que da look no !autoloot.")
if true then
local doAutoLootLook = macro(5000, function() end)
onTextMessage(function(mode, text)
if settings.lootlook then
    if mode == 20 and text:find("You see") and doAutoLootLook:isOn() then
        local regex = [[You see (?:an|a)([a-z A-Z]*).]]
        local data = regexMatch(text, regex)[1]
        if data and data[2] then
            say('!autoloot ' ..data[2]:trim())
        end
    end
end
end)
end



addCheckBox("chase", "Atacar seguindo", false, rightPanel, "Sempre atacar seguindo.")
if true then
macro(250, function()
if settings.chase then
   if g_game.isOnline() and g_game.isAttacking() then
         g_game.setChaseMode(1)
           end
           end
       end)
       end

addCheckBox("bagpe", "Puxar item do pe pra bag", false, leftPanel, "Pega o item de baixo do personagem para sua bag.")
if true then
macro(100, function()
if settings.bagpe then
  local tile = g_map.getTile(pos())
  if tile then
    for _, item in ipairs(tile:getItems()) do
      if item:isPickupable() then
        if g_game.move(item, {x=65535, y=SlotBack, z=0}, item:getCount()) then
        end
      end
    end
  end
end
end)
end

addCheckBox("bagprincipal", "Abrir bag principal", false, leftPanel, "Sempre abrir a bag principal.")
if true then
macro(1000, function()
if settings.bagprincipal then
    bpItem = getBack()
    bp = getContainer(0)

    if not bp and bpItem ~= nil then
        g_game.open(bpItem)
    end

end
end)
end


addCheckBox("summon", "Auto-Summon", false, leftPanel, "Quando seu summon morrer, vai usar a magia novamente.")
if true then

local summonName = (storage.summonnome)

function isSummonOnScreen()
    for _, spec in ipairs(getSpectators()) do
        if not spec:isPlayer() and spec:getName() == summonName then
     return true
    end
   end
end

Summon = macro(100, function()
if settings.summon then
      if not isSummonOnScreen() then
          say(storage.summonmagia)
   end
end
end)
end


  UI.Separator(leftPanel)

cor = UI.Label("Nome da magia", leftPanel)
cor:setColor("green")
cor:setFont("verdana-11px-rounded")

UI.TextEdit(storage.summonmagia or "Nome da magia", function(widget, text)   
  storage.summonmagia = text
end,leftPanel)

UI.Separator(leftPanel)
cor = UI.Label("Nome do Summon", leftPanel)
cor:setColor("green")
cor:setFont("verdana-11px-rounded")

UI.TextEdit(storage.summonnome or "Nome do Summon", function(widget, text)   
  storage.summonnome = text
end,leftPanel)





UI.Separator(rightPanel)
cor = UI.Label("Parar Cave/Target\nBotao de Atalho:", rightPanel)
cor:setColor("green")
cor:setFont("verdana-11px-rounded")


onKeyPress(function(keys)
if keys == (storage.stopcave) then
if CaveBot.isOn() or TargetBot.isOn() then
CaveBot.setOff()
TargetBot.setOff()
elseif CaveBot.isOff() or TargetBot.isOff() then
CaveBot.setOn()
TargetBot.setOn()
end
end
end)

UI.TextEdit(storage.stopcave or "Shift+Space", function(widget, text)   
  storage.stopcave = text
end,rightPanel)

UI.Label(" ", rightPanel)
macro(1, "Virar [SETINHAS]", function()

  if modules.corelib.g_keyboard.isKeyPressed('Up') then
    turn(0)
  elseif modules.corelib.g_keyboard.isKeyPressed('Right') then
    turn(1)
  elseif modules.corelib.g_keyboard.isKeyPressed('Down') then
    turn(2)
  elseif modules.corelib.g_keyboard.isKeyPressed('Left') then
    turn(3)
  end
end,rightPanel)

UI.Label(" ", rightPanel)

macro(1, 'SENSE .', function()
  if g_game.isAttacking() then
    storage.Sense = g_game.getAttackingCreature():getName()
  end
      if storage.Sense then
          locatePlayer = getPlayerByName(storage.Sense)
          if not (locatePlayer and locatePlayer:getPosition().z == player:getPosition().z and getDistanceBetween(pos(), locatePlayer:getPosition()) <= 6) then
              say('sense "' .. storage.Sense)
              delay(1000)
          end
      end
  end,rightPanel)


  onTalk(function(name, level, mode, text, channelId, pos)
      if player:getName() == name then
          if string.sub(text, 1, 1) == '.' then
              local checkMsg = string.sub(text, 2, 1000):trim()
              print(checkMsg)
              if checkMsg == '' then
                  storage.Sense = false
              else
                  storage.Sense = checkMsg
              end
          end
      end
  end)


addCheckBox("limpartexto", "Limpar Textos", false, leftPanel, "Sem mensagens Laranja na tela.")
if true then
onStaticText(function(thing, text)
    if settings.limpartexto and not text:find('says:') then
        g_map.cleanTexts()
    end
end)
end

addCheckBox("esconderspr", "Esconder Sprites", false, leftPanel, "Esconder todos os efeitos do jogo.")
if true then
end
spr = macro(100, function() end)
onAddThing(function(tile, thing)
    if spr.isOff() then return end
    if thing:isEffect() and settings.esconderspr then
        thing:hide()
    end
end)
